{"version":3,"file":"webmidi.cjs.min.js","sources":["../node_modules/djipevents/dist/djipevents.esm.min.js","../src/Utilities.js","../src/Note.js","../src/InputChannel.js","../src/Input.js","../src/OutputChannel.js","../src/Output.js","../src/WebMidi.js"],"sourcesContent":["class e{constructor(e=!1){this.eventMap={},this.eventsSuspended=1==e}addListener(n,r,i={}){if(\"string\"==typeof n&&n.length<1||n instanceof String&&n.length<1||\"string\"!=typeof n&&!(n instanceof String)&&n!==e.ANY_EVENT)throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");if(\"function\"!=typeof r)throw new TypeError(\"The callback must be a function.\");const s=new t(n,this,r,i);return this.eventMap[n]||(this.eventMap[n]=[]),i.prepend?this.eventMap[n].unshift(s):this.eventMap[n].push(s),s}addOneTimeListener(e,t,n={}){n.remaining=1,this.addListener(e,t,n)}static get ANY_EVENT(){return Symbol.for(\"Any event\")}hasListener(n,r){if(void 0===n)return!!(this.eventMap[e.ANY_EVENT]&&this.eventMap[e.ANY_EVENT].length>0)||Object.entries(this.eventMap).some(([,e])=>e.length>0);if(this.eventMap[n]&&this.eventMap[n].length>0){if(r instanceof t){return this.eventMap[n].filter(e=>e===r).length>0}if(\"function\"==typeof r){return this.eventMap[n].filter(e=>e.callback===r).length>0}return null==r}return!1}get eventNames(){return Object.keys(this.eventMap)}getListeners(e){return this.eventMap[e]||[]}suspendEvent(e){this.getListeners(e).forEach(e=>{e.suspended=!0})}unsuspendEvent(e){this.getListeners(e).forEach(e=>{e.suspended=!1})}getListenerCount(e){return this.getListeners(e).length}emit(t,...n){if(\"string\"!=typeof t&&!(t instanceof String))throw new TypeError(\"The 'event' parameter must be a string.\");if(this.eventsSuspended)return;let r=[],i=this.eventMap[e.ANY_EVENT]||[];return this.eventMap[t]&&(i=i.concat(this.eventMap[t])),i.forEach(e=>{if(e.suspended)return;let t=[...n];Array.isArray(e.arguments)&&(t=t.concat(e.arguments)),e.remaining>0&&(r.push(e.callback.apply(e.context,t)),e.count++),--e.remaining<1&&e.remove()}),r}removeListener(e,t,n={}){if(void 0===e)return void(this.eventMap={});if(!this.eventMap[e])return;let r=this.eventMap[e].filter(e=>t&&e.callback!==t||n.remaining&&n.remaining!==e.remaining||n.context&&n.context!==e.context);r.length?this.eventMap[e]=r:delete this.eventMap[e]}async waitFor(e,t={}){return t.duration=parseInt(t.duration),(isNaN(t.duration)||t.duration<=0)&&(t.duration=1/0),new Promise((n,r)=>{let i,s=this.addListener(e,()=>{clearTimeout(i),n()},{remaining:1});t.duration!==1/0&&(i=setTimeout(()=>{s.remove(),r(\"The duration expired before the event was emitted.\")},t.duration))})}get eventCount(){return Object.keys(this.eventMap).length}}class t{constructor(t,n,r,i={}){if(\"string\"!=typeof t&&!(t instanceof String)&&t!==e.ANY_EVENT)throw new TypeError(\"The 'event' parameter must be a string or EventEmitter.ANY_EVENT.\");if(!n)throw new ReferenceError(\"The 'target' parameter is mandatory.\");if(\"function\"!=typeof r)throw new TypeError(\"The 'callback' must be a function.\");void 0===i.arguments||Array.isArray(i.arguments)||(i.arguments=[i.arguments]),(i=Object.assign({context:n,remaining:1/0,arguments:void 0,duration:1/0},i)).duration!==1/0&&setTimeout(()=>this.remove(),i.duration),this.event=t,this.target=n,this.callback=r,this.context=i.context,this.remaining=parseInt(i.remaining)>=1?parseInt(i.remaining):1/0,this.count=0,this.arguments=i.arguments,this.suspended=!1}remove(){this.target.removeListener(this.event,this.callback,{context:this.context,remaining:this.remaining})}}export{e as EventEmitter,t as Listener};\n//# sourceMappingURL=djipevents.esm.min.js.map\n","import {Note} from \"./Note.js\";\nimport {WebMidi} from \"./WebMidi.js\";\n\n/**\n * The `Utilities` class contains general-purpose utility functions. The class is a singleton (its\n * methode are static) and is not meant to be instantiated.\n *\n * @since 3.0.0\n */\nclass Utilities {\n\n  /**\n   * Returns a MIDI note number matching the note name passed in the form of a string parameter. The\n   * note name must include the octave number. The name can also optionally include a sharp (#),\n   * a double sharp (##), a flat (b) or a double flat (bb) symbol. For example, these are all valid\n   * names: C5, G4, D#-1, F0, Gb7, Eb-1, Abb4, B##6, etc.\n   *\n   * When converting note names to numbers, C4 is considered to be middle C (MIDI note number 60) as\n   * per the scientific pitch notation standard.\n   *\n   * The resulting note number can be offset by using the `octaveOffset` parameter.\n   *\n   * @param name {string} The name of the note in the form of a letter, followed by an optional \"#\",\n   * \"##\", \"b\" or \"bb\" followed by the octave number. For exemple: C5, G4, D#-1, F0, Gb7, Eb-1,\n   * Abb4, B##6, etc.\n   *\n   * @param {number} [octaveOffset=0] A integer to offset the octave by.\n   *\n   * @returns {number} The MIDI note number (an integer between 0 and 127).\n   *\n   * @throws RangeError Invalid 'octaveOffset' value\n   *\n   * @throws TypeError Invalid note name\n   *\n   * @since 3.0.0\n   */\n  getNoteNumberByName(name, octaveOffset = 0) {\n\n    // Validation\n    octaveOffset = octaveOffset == undefined ? 0 : parseInt(octaveOffset);\n    if (isNaN(octaveOffset)) throw new RangeError(\"Invalid 'octaveOffset' value\");\n    if (typeof name !== \"string\") name = \"\";\n\n    const fragments = this.getNoteFragments(name);\n    if (!fragments) throw new TypeError(\"Invalid note name\");\n\n    const notes = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };\n    let result = (fragments.octave + 1 + octaveOffset) * 12;\n    result += notes[fragments.letter];\n\n    if (fragments.accidental) {\n      if (fragments.accidental.startsWith(\"b\")) {\n        result -= fragments.accidental.length;\n      } else {\n        result += fragments.accidental.length;\n      }\n    }\n\n    if (result < 0 || result > 127) throw new RangeError(\"Invalid octaveOffset value\");\n\n    return result;\n\n  }\n\n  /**\n   * Given a proper note name (\"C#4\", \"Gb-1\", etc.), this method returns an object containing the\n   * fragments composing it (uppercase letter, accidental and octave).\n   *\n   * @param name\n   * @returns {{octave: number, letter: string, accidental: string}}\n   *\n   * @throws TypeError Invalid note name\n   *\n   * @since 3.0.0\n   */\n  getNoteFragments(name) {\n\n    const matches = name.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\\d+)$/i);\n    if (!matches) throw new TypeError(\"Invalid note name\");\n\n    const letter = matches[1].toUpperCase();\n    const octave = parseInt(matches[3]);\n    let accidental = matches[2].toLowerCase();\n    accidental = accidental === \"\" ? undefined : accidental;\n\n    const fragments = {\n      letter: letter,\n      accidental: accidental,\n      octave: octave,\n      name: letter + (accidental || \"\") + octave\n    };\n\n    return fragments;\n\n  }\n\n  /**\n   * Returns a sanitized array of valid MIDI channel numbers (1-16). The parameter should be a\n   * single integer or an array of integers.\n   *\n   * For backwards-compatibility, passing `undefined` as a parameter to this method results in all\n   * channels being returned (1-16). Otherwise, parameters that cannot successfully be parsed to\n   * integers between 1 and 16 are silently ignored.\n   *\n   * @param [channel] {number|number[]} An integer or an array of integers to parse as channel\n   * numbers.\n   *\n   * @returns {Array} An array of 0 or more valid MIDI channel numbers.\n   *\n   * @since 3.0.0\n   */\n  sanitizeChannels(channel) {\n\n    let channels;\n\n    if (this.validation) {\n\n      if (channel === \"all\") { // backwards-compatibility\n        channels = [\"all\"];\n      } else if (channel === \"none\") { // backwards-compatibility\n        return [];\n      }\n\n    }\n\n    if (!Array.isArray(channel)) {\n      channels = [channel];\n    } else {\n      channels = channel;\n    }\n\n    // In order to preserve backwards-compatibility, we let this assignment as it is.\n    if (channels.indexOf(\"all\") > -1) {\n      channels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n    }\n\n    return channels\n      .map(function(ch) {\n        return parseInt(ch);\n      })\n      .filter(function(ch) {\n        return (ch >= 1 && ch <= 16);\n      });\n\n  }\n\n  /**\n   * Returns a valid timestamp, relative to the navigation start of the document, derived from the\n   * `time` parameter. If the parameter is a string starting with the \"+\" sign and followed by a\n   * number, the resulting timestamp will be the sum of the current timestamp plus that number. If\n   * the parameter is a positive number, it will be returned as is. Otherwise, false will be\n   * returned.\n   *\n   * @param [time] {number|string} The time string (e.g. `\"+2000\"`) or number to parse\n   * @return {number|false} A positive number or `false` (if the time cannot be converted)\n   *\n   * @since 3.0.0\n   */\n  convertToTimestamp(time) {\n\n    let value = false;\n    let parsed = parseFloat(time);\n    if (isNaN(parsed)) return false;\n\n    if (typeof time === \"string\" && time.substring(0, 1) === \"+\") {\n      if (parsed >= 0) value = this.time + parsed;\n    } else {\n      if (parsed >= 0) value = parsed;\n    }\n\n    return value;\n\n  }\n\n  /**\n   * Returns a valid MIDI note number (0-127) given the specified input. The parameter usually is a\n   * string containing a note name (`\"C3\"`, `\"F#4\"`, `\"D-2\"`, `\"G8\"`, etc.). If an integer between 0\n   * and 127 is passed, it will simply be returned as is (for convenience). Other strings will be\n   * parsed for integer, if possible.\n   *\n   * If the input is a string, the resulting note number is offset by the\n   * [octaveOffset]{@link WebMidi#octaveOffset} value (if not zero). For example, if you pass in\n   * \"C4\" and the [octaveOffset]{@link WebMidi#octaveOffset} value is 2, the resulting MIDI note\n   * number will be 36.\n   *\n   * **Note**: since v3.x, this method returns `false` instead of throwing an error when the input\n   * is invalid.\n   *\n   * @param input {string|number} A string to extract the note number from. An integer can also be\n   * used, in this case it will simply be returned as is (if between 0 and 127).\n   *\n   * @returns {number|false} A valid MIDI note number (0-127) or `false` if the input could not\n   * successfully be parsed to a note number.\n   *\n   * @since 3.0.0\n   */\n  guessNoteNumber(input, options = {}) {\n\n    if (options.octaveOffset == undefined) options.octaveOffset = 0;\n    options.octaveOffset = parseInt(options.octaveOffset);\n\n    let output = false;\n\n    if (Number.isInteger(input) && input >= 0 && input <= 127) {        // uint\n      output = parseInt(input);\n    } else if (parseInt(input) >= 0 && parseInt(input) <= 127) {        // float or uint as string\n      output = parseInt(input);\n    } else if (typeof input === \"string\" || input instanceof String) {  // string\n      output = this.getNoteNumberByName(input, {octaveOffset: this.octaveOffset});\n    }\n\n    if (output === false) return false;\n    return output;\n\n  }\n\n  /**\n   * Converts the `input` parameter to a valid {@link Note} object. The input usually is an unsigned\n   * integer (0-127) or a note name (`\"C4\"`, `\"G#5\"`, etc.). If the input is a {@link Note} object,\n   * it will be returned as is.\n   *\n   * If the input is a note number or name, it is possible to specify options by providing the\n   * optional `options` parameter.\n   *\n   * An error is thrown for invalid input.\n   *\n   * @param [input] {number|string|Note}\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should\n   * be explicitly stopped.\n   *\n   * @param {number} [options.attack=0.5] The note's attack velocity as a decimal number between 0\n   * and 1.\n   *\n   * @param {number} [options.release=0.5] The note's release velocity as a decimal number between 0\n   * and 1.\n   *\n   * @param {number} [options.rawAttack=64] The note's attack velocity as an integer between 0 and\n   * 127.\n   *\n   * @param {number} [options.rawRelease=64] The note's release velocity as an integer between 0 and\n   * 127.\n   *\n   * @param {number} [options.octaveOffset=0] An integer to offset the octave by.\n   *\n   * @returns {Note}\n   *\n   * @throws TypeError The input could not be parsed as a note\n   *\n   * @since version 3.0.0\n   */\n  getNoteObject(input, options= {}) {\n\n    if (options.octaveOffset == undefined) options.octaveOffset = 0;\n\n    if (input instanceof Note) {\n      return input;\n    } else {\n      let number = this.guessNoteNumber(input, {octaveOffset: options.octaveOffset});\n      if (number !== false) {\n        return new Note(number, options);\n      } else {\n        throw new TypeError(`The input could not be parsed as a note (${input})`);\n      }\n    }\n\n  }\n\n  /**\n   * Converts an input value, which can be an unsigned integer (0-127), a note name, a {@link Note}\n   * object or an array of the previous types, to an array of {@link Note} objects.\n   *\n   * {@link Note} objects are returned as is. For note numbers and names, a {@link Note} object is\n   * created with the options specified. An error will be thrown when encountering invalid input.\n   *\n   * @param [notes] {number|string|Note|number[]|string[]|Note[]}\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should\n   * be explicitly stopped.\n   *\n   * @param {number} [options.attack=0.5] The note's attack velocity as a decimal number between 0\n   * and 1.\n   *\n   * @param {number} [options.release=0.5] The note's release velocity as a decimal number between 0\n   * and 1.\n   *\n   * @param {number} [options.rawAttack=64] The note's attack velocity as an integer between 0 and\n   * 127.\n   *\n   * @param {number} [options.rawRelease=64] The note's release velocity as an integer between 0 and\n   * 127.\n   *\n   * @returns {Note[]}\n   *\n   * @throws TypeError An element could not be parsed as a note.\n   *\n   * @since 3.0.0\n   */\n  getValidNoteArray(notes, options = {}) {\n\n    let result = [];\n    if (!Array.isArray(notes)) notes = [notes];\n\n    notes.forEach(note => {\n      result.push(this.getNoteObject(note, options));\n    });\n\n    return result;\n\n  }\n\n  /**\n   * Returns a string representing a note name (with optional accidental) followed by an octave\n   * number. The octave can be offset by using the `octaveOffset` parameter.\n   *\n   * @param {number} The MIDI note number to convert to a note name\n   * @param {octaveOffset}\n   * @returns {string}\n   *\n   * @throws RangeError Invalid note number\n   * @throws RangeError Invalid octaveOffset value\n   *\n   * @since 3.0.0\n   */\n  getNoteNameByNumber(number, octaveOffset) {\n\n    number = parseInt(number);\n    if (isNaN(number) || number < 0 || number > 127) throw new RangeError(\"Invalid note number\");\n\n    octaveOffset = octaveOffset == undefined ? 0 : parseInt(octaveOffset);\n    if (isNaN(octaveOffset)) throw new RangeError(\"Invalid octaveOffset value\");\n\n    const octave = Math.floor(number / 12 - 1) + octaveOffset;\n    return WebMidi.NOTES[number % 12] + octave.toString();\n\n  }\n\n}\n\n// Export singleton instance of Utilities class. The 'constructor' is nulled so that it cannot be\n// used to instantiate a new Utilities object or extend it. However, it is not freezed so it remains\n// extensible (properties can be added at will).\nconst utils = new Utilities();\nutils.constructor = null;\nexport {utils as Utilities};\n","import {WebMidi} from \"./WebMidi.js\";\nimport {Utilities} from \"./Utilities.js\";\n\n/**\n * The `Note` class represents a single musical note such as `\"D3\"`, `\"G#4\"`, `\"F-1\"`, `\"Gb7\"`, etc.\n *\n * Note that a `Note` object does not have a MIDI number per se. The MIDI note number is determined\n * when the note is played. This is because, the `octaveOffset` property of various objects\n * (`WebMidi`, `OutputChannel`, `Output`, etc.) can be used to offset the note number to match\n * external devices where middle C is not equal to C4.\n *\n * The octave of the note has no intrinsic limit. You can specify a note to be \"F27\" or \"G#-16\".\n * However, to play such notes on a MIDI channel, the channel will need to be offset accordingly.\n *\n * `Note` objects can be played back on a single channel by calling\n * [OutputChannel.playNote()]{@link OutputChannel#playNote}. A note can also be played back on the\n * multiple channels of an output by using [Output.playNote()]{@link Output#playNote}.\n *\n * The note has attack and release velocities set at 64 by default. These can be changed by passing\n * in the appropriate option. It is also possible to set a system-wide default for attack and\n * release velocities by using the `WebMidi.defaults` property.\n *\n * The note may have a duration. If it does, playback will be stopped when the duration has elapsed\n * by automatically sending a **noteoff** event. By default, the duration is set to `Infinity`. In\n * this case, it will never stop playing unless explicitly stopped by calling a method such as\n * [OutputChannel.stopNote()]{@link OutputChannel#stopNote},\n * [Output.stopNote()]{@link Output#stopNote} or similar.\n *\n * @param value {string|number} The value used to create the note. If a string is used, it must be\n * the note name (with optional accidental) followed by the octave (`\"C3\"`, `\"G#4\"`, `\"F-1\"`,\n * `\"Db7\"`, etc.). If a number is used, it must be an integer between 0 and 127. The number will be\n * converted to a note name. In this case, middle C is considered to be C4 (note number 60) but that\n * can be offset with the `octaveOffset`property.\n *\n * @param {Object} [options={}]\n *\n * @param {number} [options.duration=Infinity] The number of milliseconds before the note should be\n * explicitly stopped.\n *\n * @param {number} [options.attack=64] The note's attack velocity as an integer between 0 and\n * 127.\n *\n * @param {number} [options.release=64] The note's release velocity as an integer between 0 and\n * 127.\n *\n * @param {number} [options.octaveOffset=0] An integer to offset the octave value. **This is only\n * used when the note is specified using a MIDI note number.**\n *\n * @throws {Error} Invalid note name\n * @throws {RangeError} Invalid duration\n * @throws {RangeError} Invalid attack value\n * @throws {RangeError} Invalid release value\n * @throws {RangeError} Invalid 'octaveOffset' value\n *\n * @since 3.0.0\n */\nexport class Note {\n\n  constructor(value, options = {}) {\n\n    // Assign property defaults\n    this.duration = WebMidi.defaults.note.duration;\n    this.attack = WebMidi.defaults.note.attack;\n    this.release = WebMidi.defaults.note.release;\n\n    // Assign property values from options (validation occurs in setter)\n    if (options.duration != undefined) this.duration = options.duration;\n    if (options.attack != undefined) this.attack = options.attack;\n    if (options.release != undefined) this.release = options.release;\n\n    // Validate and assign options.octaveOffset value\n    options.octaveOffset = options.octaveOffset == undefined ? 0 :parseInt(options.octaveOffset);\n    if (isNaN(options.octaveOffset)) throw new RangeError(\"Invalid 'octaveOffset' value\");\n\n    // Assign note depending on the way it was specified (name or number)\n    if (Number.isInteger(value)) {\n      this.name = Utilities.getNoteNameByNumber(value, options.octaveOffset);\n    } else {\n      this.name = value;\n    }\n\n  }\n\n  /**\n   * The name of the note as a string combining the note, an optional accidental and the octave.\n   * @type {string}\n   * @since 3.0.0\n   */\n  get name() {\n    return this._name;\n  }\n  set name(value) {\n\n    if (WebMidi.validation) {\n      value = Utilities.getNoteFragments(value).name;\n      if (!value) throw new Error(\"Invalid note name\");\n    }\n\n    this._name = value;\n\n  }\n\n  /**\n   * The duration of the note as a positive decimal number representing the number of milliseconds\n   * that the note should play for.\n   *\n   * @type {number}\n   * @since 3.0.0\n   */\n  get duration() {\n    return this._duration;\n  }\n  set duration(value) {\n\n    if (WebMidi.validation) {\n      value = parseFloat(value);\n      if (isNaN(value) || value === null || value < 0) throw new RangeError(\"Invalid duration.\");\n    }\n\n    this._duration = value;\n\n  }\n\n  /**\n   * The attack velocity of the note as an integer between 0 and 127.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get attack() {\n    return this._attack;\n  }\n  set attack(value) {\n\n    if (WebMidi.validation) {\n      value = parseFloat(value);\n      if (isNaN(value) || !(value >= 0 && value <= 127)) {\n        throw new RangeError(\"Invalid attack value.\");\n      }\n    }\n\n    this._attack = value;\n\n  }\n\n  /**\n   * The release velocity of the note as an integer between 0 and 127.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get release() {\n    return this._release;\n  }\n  set release(value) {\n\n    if (WebMidi.validation) {\n      value = parseFloat(value);\n      if (isNaN(value) || !(value >= 0 && value <= 127)) {\n        throw new RangeError(\"Invalid release value.\");\n      }\n    }\n\n    this._release = value;\n\n  }\n\n  /**\n   * The attack velocity of the note as a decimal number between 0 and 1.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get attackNormalized() {\n    return this._attack / 127;\n  }\n\n  /**\n   * The release velocity of the note as a decimal number between 0 and 1.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get releaseNormalized() {\n    return this._release / 127;\n  }\n\n}\n","import {EventEmitter} from \"../node_modules/djipevents/dist/djipevents.esm.min.js\";\nimport {WebMidi} from \"./WebMidi.js\";\nimport {Note} from \"./Note.js\";\n\n/**\n * The `InputChannel` class represents a single input MIDI channel (1-16) from a single input\n * device. This object is derived from the host's MIDI subsystem and cannot be instantiated\n * directly.\n *\n * All 16 `InputChannel` objects can be found inside the input's [channels]{@link Input#channels}\n * property.\n *\n * The `InputChannel` class extends the\n * [EventEmitter](https://djipco.github.io/djipevents/EventEmitter.html) class from the\n * [djipevents]{@link https://djipco.github.io/djipevents/index.html} module. This means\n * it also includes methods such as\n * [addListener()](https://djipco.github.io/djipevents/EventEmitter.html#addListener),\n * [removeListener()](https://djipco.github.io/djipevents/EventEmitter.html#removeListener),\n * [hasListener()](https://djipco.github.io/djipevents/EventEmitter.html#hasListener) and several\n * others. Check out the\n * [documentation for EventEmitter](https://djipco.github.io/djipevents/EventEmitter.html) for more\n * details.\n *\n * @param {Input} input The `Input` this channel belongs to\n * @param {number} number The MIDI channel's number (1-16)\n *\n * @fires InputChannel#midimessage\n *\n * @fires InputChannel#noteoff\n * @fires InputChannel#noteon\n * @fires InputChannel#keyaftertouch\n * @fires InputChannel#controlchange\n * @fires InputChannel#channelmode\n * @fires InputChannel#programchange\n * @fires InputChannel#channelaftertouch\n * @fires InputChannel#pitchbend\n *\n * @fires InputChannel#allnotesoff\n * @fires InputChannel#allsoundoff\n * @fires InputChannel#localcontrol\n * @fires InputChannel#monomode\n * @fires InputChannel#omnimode\n * @fires InputChannel#resetallcontrollers\n *\n * @since 3.0.0\n */\nexport class InputChannel extends EventEmitter {\n\n  constructor(input, number) {\n\n    super();\n\n    /**\n     * The {@link Input} this channel belongs to\n     * @type {Input}\n     */\n    this.input = input;\n\n    /**\n     * This channel's number (1-16)\n     * @type {number}\n     */\n    this.number = number;\n\n    /**\n     * @type {OutputChannel|OutputChannel[]}\n     * @private\n     */\n    this._forwardTo = undefined;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this._octaveOffset = 0;\n\n    // /**\n    //  * An array of the current NRPNs being constructed for this channel\n    //  *\n    //  * @private\n    //  *\n    //  * @type {string[]}\n    //  */\n    // this._nrpnBuffer = [];\n    //\n    // // Enable NRPN events by default\n    // this.nrpnEventsEnabled = true;\n\n  }\n\n  destroy() {\n    this.input = null;\n    this.number = null;\n    // this._nrpnBuffer = null;\n    // this._nrpnEventsEnabled = false;\n    this.removeListener();\n  }\n\n  /**\n   * @param e Event\n   * @protected\n   */\n  _parseEvent(e) {\n\n    // @todo check if message must be forwarded\n    // if (this.forwardTo) {\n    //   this.forwardTo.forEach(channel => channel.sendRaw(e.data));\n    // }\n\n    // Extract data bytes (unless it's a sysex message)\n    let dataBytes = null;\n    if (e.data[0] !== WebMidi.MIDI_SYSTEM_MESSAGES.sysex) dataBytes = e.data.slice(1);\n\n    /**\n     * Event emitted when a MIDI message of any kind is received by the `InputChannel`.\n     *\n     * @event InputChannel#midimessage\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} event.statusByte The message's status byte.\n     * @property {?number[]} event.dataBytes The message's data bytes as an array of 0, 1 or 2\n     * integers. This will be null for `sysex` messages.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"midimessage\"`\n     */\n    let midiMessageEvent = {\n      target: this,\n      data: Array.from(e.data),\n      rawData: e.data,\n      statusByte: e.data[0],\n      dataBytes: dataBytes,\n      timestamp: e.timeStamp,\n      type: \"midimessage\"\n    };\n\n    this.emit(\"midimessage\", midiMessageEvent);\n\n    // Parse the event to see if its part of an NRPN sequence\n    // this._parseEventForNrpnMessage(e);\n\n    // Parse the inbound event for regular messages\n    this._parseEventForStandardMessages(e);\n\n  }\n\n  getStructuredMidiMessage(data) {\n\n    return {\n      command: data[0] >> 4,\n      data1: data.length > 1 ? data[1] : undefined,\n      data2: data.length > 2 ? data[2] : undefined\n    };\n\n  }\n\n  /**\n   * Parses channel events for standard (non-NRPN) events.\n   * @param e Event\n   * @private\n   */\n  _parseEventForStandardMessages(e) {\n\n    let {command, data1, data2} = this.getStructuredMidiMessage(e.data);\n\n    // Returned event\n    let event = {\n      target: this,\n      data: Array.from(e.data),\n      rawData: e.data,\n      timestamp: e.timeStamp\n    };\n\n    if (\n      command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.noteoff ||\n      (command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.noteon && data2 === 0)\n    ) {\n\n      /**\n       * Event emitted when a **note off** MIDI message has been received.\n       *\n       * @event InputChannel#noteoff\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a `Uint8Array`.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"noteoff\"`\n       * @property {Object} note A {@link Note} object containing information such as note number,\n       * note name and octave.\n       * @property {number} release The release velocity expressed as a float between 0 and 1.\n       * @property {number} rawRelease The release velocity expressed as an integer (between 0 and\n       * 127).\n       */\n      event.type = \"noteoff\";\n      event.note = new Note(\n        data1,\n        {\n          rawRelease: data2,\n          octaveOffset: this.octaveOffset + this.input.octaveOffset + WebMidi.octaveOffset\n        }\n      );\n      event.release = event.note.release;\n      event.rawRelease = event.note.rawRelease;\n\n    } else if (command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.noteon) {\n\n      /**\n       * Event emitted when a **note on** MIDI message has been received.\n       *\n       * @event InputChannel#noteon\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"noteon\"`\n       * @property {Object} note A {@link Note} object containing information such as note number,\n       * note name and octave.\n       * @property {number} attack The attack velocity expressed as a float between 0 and 1.\n       * @property {number} rawAttack The attack velocity expressed as an integer (between 0 and\n       * 127).\n       */\n      event.type = \"noteon\";\n      event.note = new Note(\n        data1,\n        {\n          rawAttack: data2,\n          octaveOffset: this.octaveOffset + this.input.octaveOffset + WebMidi.octaveOffset\n        }\n      );\n      event.attack = event.note.attack;\n      event.rawAttack = event.note.rawAttack;\n\n    } else if (command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.keyaftertouch) {\n\n      /**\n       * Event emitted when a **key-specific aftertouch** MIDI message has been received.\n       *\n       * @event InputChannel#keyaftertouch\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a `Uint8Array`.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"keyaftertouch\"`\n       * @property {Object} note A {@link Note} object containing information such as note number,\n       * note name and octave.\n       * @property {number} value The aftertouch amount expressed as a float between 0 and 1.\n       * @property {number} rawValue The aftertouch amount expressed as an integer (between 0 and\n       * 127).\n       */\n      event.type = \"keyaftertouch\";\n      event.note = new Note(\n        data1,\n        {octaveOffset: this.octaveOffset + this.input.octaveOffset + WebMidi.octaveOffset}\n      );\n      event.value = data2 / 127;\n      event.rawValue = data2;\n\n    } else if (\n      command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.controlchange &&\n      data1 >= 0 && data1 <= 119\n    ) {\n\n      /**\n       * Event emitted when a **control change** MIDI message has been received.\n       *\n       * @event InputChannel#controlchange\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"controlchange\"`\n       * @property {Object} controller\n       * @property {Object} controller.number The number of the controller.\n       * @property {Object} controller.name The usual name or function of the controller.\n       * @property {number} value The value expressed as a float between 0 and 1.\n       * @property {number} rawValue The value expressed as an integer (between 0 and 127).\n       */\n      event.type = \"controlchange\";\n      event.controller = {\n        number: data1,\n        name: this.getCcNameByNumber(data1)\n      };\n      event.value = data2 / 127;\n      event.rawValue = data2;\n\n    } else if (\n      command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.channelmode &&\n      data1 >= 120 && data1 <= 127\n    ) {\n\n      /**\n       * Event emitted when a **channel mode** MIDI message has been received.\n       *\n       * @event InputChannel#channelmode\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"channelmode\"`\n       * @property {Object} controller\n       * @property {Object} controller.number The number of the controller.\n       * @property {Object} controller.name The usual name or function of the controller.\n       * @property {number} value The value expressed as a float between 0 and 1.\n       * @property {number} rawValue The value expressed as an integer (between 0 and 127).\n       */\n      event.type = \"channelmode\";\n      event.controller = {\n        number: data1,\n        name: this.getChannelModeByNumber(data1)\n      };\n      event.value = data2;\n\n      // Also dispatch specific channel mode events\n      this._parseChannelModeMessage(e);\n\n    } else if (command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.programchange) {\n\n      /**\n       * Event emitted when a **program change** MIDI message has been received.\n       *\n       * @event InputChannel#programchange\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"programchange\"`\n       * @property {number} value The value expressed as an integer between 1 and 128.\n       * @property {number} rawValue The value expressed as an integer between 0 and 127.\n       */\n      event.type = \"programchange\";\n      event.value = data1 + 1;\n      event.rawValue = data1;\n\n    } else if (command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.channelaftertouch) {\n\n      /**\n       * Event emitted when a control change MIDI message has been received.\n       *\n       * @event InputChannel#channelaftertouch\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"channelaftertouch\"`\n       * @property {number} value The value expressed as a float between 0 and 1.\n       * @property {number} rawValue The value expressed as an integer (between 0 and 127).\n       */\n      event.type = \"channelaftertouch\";\n      event.value = data1 / 127;\n      event.rawValue = data1;\n\n    } else if (command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.pitchbend) {\n\n      /**\n       * Event emitted when a pitch bend MIDI message has been received.\n       *\n       * @event InputChannel#pitchbend\n       * @type {Object}\n       * @property {InputChannel} target The `InputChannel` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"pitchbend\"`\n       * @property {number} value The value expressed as a float between 0 and 1.\n       * @property {number} rawValue The value expressed as an integer (between 0 and 16383).\n       */\n      event.type = \"pitchbend\";\n      event.value = ((data2 << 7) + data1 - 8192) / 8192;\n      event.rawValue = (data2 << 7) + data1;\n\n    } else {\n      event.type = \"unknownmessage\";\n    }\n\n    this.emit(event.type, event);\n\n  }\n\n  /**\n   * Returns the channel mode name matching the specified number. If no match is found, the function\n   * returns `false`.\n   *\n   * @param {number} number An integer representing the channel mode message.\n   * @returns {string|false} The name of the matching channel mode or `false` if not match could be\n   * found.\n   *\n   * @since 2.0.0\n   */\n  getChannelModeByNumber(number) {\n\n    if (WebMidi.validation) {\n      number = Math.floor(number);\n    }\n\n    if ( !(number >= 120 && number <= 127) ) return false;\n\n    for (let cm in WebMidi.MIDI_CHANNEL_MODE_MESSAGES) {\n\n      if (\n        WebMidi.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(cm) &&\n        number === WebMidi.MIDI_CHANNEL_MODE_MESSAGES[cm]\n      ) {\n        return cm;\n      }\n\n    }\n\n    return false;\n\n  }\n\n  _parseChannelModeMessage(e) {\n\n    let data1, data2;\n\n    if (e.data.length > 1) {\n      data1 = e.data[1];\n      data2 = e.data.length > 2 ? e.data[2] : undefined;\n    }\n\n    // Basis for the returned event\n    let event = {\n      target: this,\n      data: Array.from(e.data),\n      rawData: e.data,\n      timestamp: e.timeStamp,\n      type: this.getChannelModeByNumber(data1)\n    };\n\n    /**\n     * Event emitted when an \"all sound off\" channel-mode MIDI message has been received.\n     *\n     * @event InputChannel#allsoundoff\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"allsoundoff\"`\n     */\n\n    /**\n     * Event emitted when a \"reset all controllers\" channel-mode MIDI message has been received.\n     *\n     * @event InputChannel#resetallcontrollers\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"resetallcontrollers\"`\n     */\n\n    /**\n     * Event emitted when a \"local control\" channel-mode MIDI message has been received. The value\n     * property of the event is set to either `true` (local control on) of `false` (local control\n     * off).\n     *\n     * @event InputChannel#localcontrol\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"localcontrol\"`\n     * @property {boolean} value For local control on, the value is `true`. For local control off,\n     * the value is `false`.\n     */\n    if (event.type === \"localcontrol\") {\n      event.value = data2 === 127 ? true : false;\n    }\n\n    /**\n     * Event emitted when an \"all notes off\" channel-mode MIDI message has been received.\n     *\n     * @event InputChannel#allnotesoff\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"allnotesoff\"`\n     */\n\n    /**\n     * Event emitted when an \"omni mode\" channel-mode MIDI message has been received. The value\n     * property of the event is set to either `true` (omni mode on) of `false` (omni mode off).\n     *\n     * @event InputChannel#omnimode\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"omnimode\"`\n     * @property {boolean} value The value is `true` for omni mode on and false for omni mode off.\n     */\n    if (event.type === \"omnimodeon\") {\n      event.type = \"omnimode\";\n      event.value = true;\n    } else if (event.type === \"omnimodeoff\") {\n      event.type = \"omnimode\";\n      event.value = false;\n    }\n\n    /**\n     * Event emitted when a \"mono/poly mode\" MIDI message has been received. The value property of\n     * the event is set to either `true` (mono mode on / poly mode off) or `false` (mono mode off /\n     * poly mode on).\n     *\n     * @event InputChannel#monomode\n     * @type {Object}\n     * @property {InputChannel} target The `InputChannel` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"monomode\"`\n     * @property {boolean} value The value is `true` for omni mode on and false for omni mode off.\n     */\n    if (event.type === \"monomodeon\") {\n      event.type = \"monomode\";\n      event.value = true;\n    } else if (event.type === \"polymodeon\") {\n      event.type = \"monomode\";\n      event.value = false;\n    }\n\n    this.emit(event.type, event);\n\n  }\n\n  // /**\n  //  * Parses channel events and constructs NRPN message parts in valid sequences.\n  //  * Keeps a separate NRPN buffer for each channel.\n  //  * Emits an event after it receives the final CC parts msb 127 lsb 127.\n  //  * If a message is incomplete and other messages are received before\n  //  * the final 127 bytes, the incomplete message is cleared.\n  //  * @param e Event\n  //  * @private\n  //  *\n  //  *\n  //  * Uint8Array [ 176, 99, 12 ]\n  //  * Uint8Array [ 176, 98, 34 ]\n  //  * Uint8Array [ 176, 6, 56 ]\n  //  * Uint8Array [ 176, 38, 78 ]\n  //  * Uint8Array [ 176, 101, 127 ]\n  //  * Uint8Array [ 176, 100, 127 ]\n  //  */\n  // _parseEventForNrpnMessage(e) {\n  //\n  //   if (!this.nrpnEventsEnabled) return;\n  //\n  //   // Extract basic data\n  //   let command = e.data[0] >> 4;\n  //   let channel = (e.data[0] & 0xf) + 1;\n  //   let data1;\n  //   let data2;\n  //\n  //   if (e.data.length > 1) {\n  //     data1 = e.data[1];\n  //     data2 = e.data.length > 2 ? e.data[2] : undefined;\n  //   }\n  //\n  //   // Message not valid for NRPN\n  //   if (\n  //     !(\n  //       command === WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.controlchange &&\n  //       (\n  //         (\n  //           data1 >= WebMidi.MIDI_NRPN_MESSAGES.increment &&\n  //           data1 <= WebMidi.MIDI_NRPN_MESSAGES.parammsb\n  //         ) ||\n  //         data1 === WebMidi.MIDI_NRPN_MESSAGES.entrymsb ||\n  //         data1 === WebMidi.MIDI_NRPN_MESSAGES.entrylsb\n  //       )\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //\n  //   // set up a CC event to parse as NRPN part\n  //   let ccEvent = {\n  //     target: this,\n  //     type: \"controlchange\",\n  //     data: Array.from(e.data),\n  //     rawData: e.data,\n  //     timestamp: e.timeStamp,\n  //     channel: channel,\n  //     controller: {\n  //       number: data1,\n  //       name: this.getCcNameByNumber(data1)\n  //     },\n  //     value: data2\n  //   };\n  //\n  //   if (\n  //     // if we get a starting MSB (CC99 - 0-126) vs an end MSB (CC99 - 127), destroy incomplete\n  //     // NRPN and begin building again\n  //     ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.parammsb &&\n  //     ccEvent.value != WebMidi.MIDI_NRPN_MESSAGES.nullactiveparameter\n  //   ) {\n  //     this._nrpnBuffer = [];\n  //     this._nrpnBuffer[0] = ccEvent;\n  //   } else if(\n  //     // add the param LSB\n  //     this._nrpnBuffer.length === 1 &&\n  //     ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.paramlsb\n  //   ) {\n  //     this._nrpnBuffer.push(ccEvent);\n  //\n  //   } else if(\n  //     // add data inc/dec or value MSB for 14bit\n  //     this._nrpnBuffer.length === 2 &&\n  //     (ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.increment ||\n  //       ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.decrement ||\n  //       ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.entrymsb)\n  //   ) {\n  //     this._nrpnBuffer.push(ccEvent);\n  //   } else if(\n  //     // if we have a value MSB, only add an LSB to pair with that\n  //     this._nrpnBuffer.length === 3 &&\n  //     this._nrpnBuffer[2].number === WebMidi.MIDI_NRPN_MESSAGES.entrymsb &&\n  //     ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.entrylsb\n  //   ) {\n  //     this._nrpnBuffer.push(ccEvent);\n  //\n  //   } else if(\n  //     // add an end MSB (CC99 - 127)\n  //     this._nrpnBuffer.length >= 3 &&\n  //     this._nrpnBuffer.length <= 4 &&\n  //     ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.parammsb &&\n  //     ccEvent.value === WebMidi.MIDI_NRPN_MESSAGES.nullactiveparameter\n  //   ) {\n  //     this._nrpnBuffer.push(ccEvent);\n  //   } else if(\n  //     // add an end LSB (CC99 - 127)\n  //     this._nrpnBuffer.length >= 4 &&\n  //     this._nrpnBuffer.length <= 5 &&\n  //     ccEvent.controller.number === WebMidi.MIDI_NRPN_MESSAGES.paramlsb &&\n  //     ccEvent.value === WebMidi.MIDI_NRPN_MESSAGES.nullactiveparameter\n  //   ) {\n  //     this._nrpnBuffer.push(ccEvent);\n  //     // now we have a full inc or dec NRPN message, lets create that event!\n  //\n  //     let rawData = [];\n  //\n  //     this._nrpnBuffer.forEach(ev => rawData.push(ev.data));\n  //\n  //     let nrpnNumber = (this._nrpnBuffer[0].value<<7) | (this._nrpnBuffer[1].value);\n  //     let nrpnValue = this._nrpnBuffer[2].value;\n  //     if (this._nrpnBuffer.length === 6) {\n  //       nrpnValue = (this._nrpnBuffer[2].value<<7) | (this._nrpnBuffer[3].value);\n  //     }\n  //\n  //     let nrpnControllerType = \"\";\n  //\n  //     switch (this._nrpnBuffer[2].controller.number) {\n  //     case WebMidi.MIDI_NRPN_MESSAGES.entrymsb:\n  //       nrpnControllerType = InputChannel.NRPN_TYPES[0];\n  //       break;\n  //     case WebMidi.MIDI_NRPN_MESSAGES.increment:\n  //       nrpnControllerType = InputChannel.NRPN_TYPES[1];\n  //       break;\n  //     case WebMidi.MIDI_NRPN_MESSAGES.decrement:\n  //       nrpnControllerType = InputChannel.NRPN_TYPES[2];\n  //       break;\n  //     default:\n  //       throw new Error(\"The NPRN type was unidentifiable.\");\n  //     }\n  //\n  //     // now we are done building an NRPN, so clear the NRPN buffer\n  //     this._nrpnBuffer = [];\n  //\n  //     /**\n  //      * Event emitted when a valid NRPN message sequence has been received.\n  //      *\n  //      * @event InputChannel#nrpn\n  //      * @type {Object}\n  //      * @property {InputChannel} target The `InputChannel` that triggered the event.\n  //      * @property {Array} event.data The MIDI message as an array of 8 bit values.\n  //      * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n  //      * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred\n  //      * (in milliseconds since the navigation start of the document).\n  //      * @property {string} type `\"nrpn\"`\n  //      * @property {Object} controller\n  //      * @property {Object} controller.number The number of the NRPN.\n  //      * @property {Object} controller.name The usual name or function of the controller.\n  //      * @property {number} value The aftertouch amount expressed as a float between 0 and 1.\n  //      * @property {number} rawValue The aftertouch amount expressed as an integer (between 0 and\n  //      * 65535).\n  //      */\n  //     let nrpnEvent = {\n  //       timestamp: ccEvent.timestamp,\n  //       channel: ccEvent.channel,\n  //       type: \"nrpn\",\n  //       data: Array.from(rawData),\n  //       rawData: rawData,\n  //       controller: {\n  //         number: nrpnNumber,\n  //         type: nrpnControllerType,\n  //         name: \"Non-Registered Parameter \" + nrpnNumber\n  //       },\n  //       value: nrpnValue / 65535,\n  //       rawValue: nrpnValue\n  //     };\n  //\n  //     this.emit(nrpnEvent.type, nrpnEvent);\n  //\n  //   } else {\n  //     // something didn't match, clear the incomplete NRPN message buffer\n  //     this._nrpnBuffer = [];\n  //   }\n  // }\n\n  /**\n   * Returns the name of a control change message matching the specified number. Some valid control\n   * change numbers do not have a specific name or purpose assigned in the MIDI\n   * [spec](https://midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2).\n   * In this case, the method returns `false`.\n   *\n   * @param {number} number An integer representing the control change message\n   * @returns {string|false} The matching control change name or `false` if not match was found\n   *\n   * @throws {RangeError} Invalid control change number.\n   *\n   * @since 2.0.0\n   */\n  getCcNameByNumber(number) {\n\n    if (WebMidi.validation) {\n      number = parseInt(number);\n      if ( !(number >= 0 && number <= 119) ) {\n        throw new RangeError(\"Invalid control change number.\");\n      }\n    }\n\n    for (let cc in WebMidi.MIDI_CONTROL_CHANGE_MESSAGES) {\n\n      if (\n        WebMidi.MIDI_CONTROL_CHANGE_MESSAGES.hasOwnProperty(cc) &&\n        number === WebMidi.MIDI_CONTROL_CHANGE_MESSAGES[cc]\n      ) {\n        return cc;\n      }\n\n    }\n\n    return false;\n\n  }\n\n  /**\n   * An integer to offset the reported octave of incoming notes. By default, middle C (MIDI note\n   * number 60) is placed on the 4th octave (C4).\n   *\n   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If\n   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.\n   *\n   * Note that this value is combined with the global offset value defined on the `WebMidi` object\n   * (if any).\n   *\n   * @type {number}\n   *\n   * @since 3.0\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(value) {\n\n    if (this.validation) {\n      value = parseInt(value);\n      if (isNaN(value)) throw new TypeError(\"The 'octaveOffset' property must be an integer.\");\n    }\n\n    this._octaveOffset = value;\n\n  }\n\n  // /**\n  //  * An `OutputChannel` object (or a list of `OutputChannel` objects) to send a copy of all\n  //  * inbound messages to. This is inspired by the THRU port on numerous MIDI devices.\n  //  *\n  //  * To stop forwarding messages, simply set `forwardTo` to `undefined` or `null`.\n  //  *\n  //  * If you want to forward messages from all channels of an input, you should instead use the\n  //  * input's [forwardTo]{@link Input#forwardTo} property.\n  //  *\n  //  * @type {OutputChannel|[OutputChannel]}\n  //  * @readonly\n  //  */\n  // get forwardTo() {\n  //   return this._forwardTo;\n  // }\n  // set forwardTo(value) {\n  //\n  //   // @todo THIS NEEDS TO BE COMPLETED!!!\n  //\n  //   if (value === undefined || value === null) {\n  //     this._forwardTo = undefined;\n  //     return;\n  //   }\n  //\n  //   if (!Array.isArray(value)) value = [value];\n  //\n  //   if (this.validation) {\n  //     value.forEach(v => {\n  //       // if (typeof v)\n  //       console.log(typeof v);\n  //     });\n  //   }\n  //\n  //   this._forwardTo = value;\n  //\n  // }\n\n  // /**\n  //  * Indicates whether events for **Non-Registered Parameter Number** should be dispatched. NRPNs\n  //  * are composed of a sequence of specific **control change** messages. When a valid sequence of\n  //  * such control change messages is received, an `nrpn` event will fire. If an invalid or out of\n  //  * order control change message is received, it will fall through the collector logic and all\n  //  * buffered control change messages will be discarded as incomplete.\n  //  *\n  //  * @type Boolean\n  //  */\n  // get nrpnEventsEnabled() {\n  //   return this._nrpnEventsEnabled;\n  // }\n  // set nrpnEventsEnabled(enabled) {\n  //   this._nrpnEventsEnabled = !!enabled;\n  // }\n\n  // /**\n  //  * Array of valid **non-registered parameter number** (NRPNs) types.\n  //  *\n  //  * @type {string[]}\n  //  * @readonly\n  //  */\n  // static get NRPN_TYPES() {\n  //   return [\"entry\", \"increment\", \"decrement\"];\n  // }\n\n}\n","import {EventEmitter} from \"../node_modules/djipevents/dist/djipevents.esm.min.js\";\nimport {WebMidi} from \"./WebMidi.js\";\nimport {InputChannel} from \"./InputChannel.js\";\nimport {Utilities} from \"./Utilities.js\";\n\n/**\n * The `Input` class represents a single MIDI input port. This object is derived from the host's\n * MIDI subsystem and cannot be instantiated directly.\n *\n * You can find a list of all currently available `Input` objects in the {@link WebMidi#inputs}\n * array.\n *\n * The `Input` class extends the\n * [EventEmitter](https://djipco.github.io/djipevents/EventEmitter.html) class from the\n * [djipevents]{@link https://djipco.github.io/djipevents/index.html} module. This means\n * it also includes methods such as\n * [getListeners()](https://djipco.github.io/djipevents/EventEmitter.html#getListeners),\n * [emit()](https://djipco.github.io/djipevents/EventEmitter.html#emit),\n * [suspendEvent()](https://djipco.github.io/djipevents/EventEmitter.html#suspendEvent) and several\n * others.\n *\n * @param {MIDIInput} midiInput `MIDIInput` object as provided by the MIDI subsystem (Web MIDI API).\n *\n * @fires Input#opened\n * @fires Input#disconnected\n * @fires Input#closed\n * @fires Input#midimessage\n * @fires Input#sysex\n * @fires Input#timecode\n * @fires Input#songposition\n * @fires Input#songselect\n * @fires Input#tunerequest\n * @fires Input#clock\n * @fires Input#start\n * @fires Input#continue\n * @fires Input#stop\n * @fires Input#activesensing\n * @fires Input#reset\n * @fires Input#midimessage\n * @fires Input#unknownmidimessage\n */\nexport class Input extends EventEmitter {\n\n  constructor(midiInput) {\n\n    super();\n\n    /**\n     * Reference to the actual MIDIInput object\n     * @private\n     */\n    this._midiInput = midiInput;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this._octaveOffset = 0;\n\n    /**\n     * Array containing the 16 {@link InputChannel} objects available for this `Input`. The\n     * channels are numbered 1 through 16.\n     *\n     * @type {InputChannel[]}\n     */\n    this.channels = [];\n    for (let i = 1; i <= 16; i++) this.channels[i] = new InputChannel(this, i);\n\n    // Setup listeners\n    this._midiInput.onstatechange = this._onStateChange.bind(this);\n    this._midiInput.onmidimessage = this._onMidiMessage.bind(this);\n\n  }\n\n  /**\n   * Destroys the `Input` by remove all listeners, emptying the `channels` array and unlinking the\n   * MIDI subsystem.\n   *\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    this.removeListener();\n    this.channels.forEach(ch => ch.destroy());\n    this.channels = [];\n    this._midiInput.onstatechange = null;\n    this._midiInput.onmidimessage = null;\n    await this.close();\n    this._midiInput = null;\n  }\n\n  /**\n   * Executed when a `\"statechange\"` event occurs.\n   *\n   * @param e\n   * @private\n   */\n  _onStateChange(e) {\n\n    let event = {\n      timestamp: WebMidi.time,\n      target: this\n    };\n\n    if (e.port.connection === \"open\") {\n\n      /**\n       * Event emitted when the {@link Input} has been opened by calling the {@link Input#open}\n       * method.\n       *\n       * @event Input#opened\n       * @type {Object}\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"opened\"`\n       * @property {Input} target The object that triggered the event\n       */\n      event.type = \"opened\";\n      this.emit(\"opened\", event);\n\n    } else if (e.port.connection === \"closed\" && e.port.state === \"connected\") {\n\n      /**\n       * Event emitted when the {@link Input} has been closed by calling the {@link Input#close}\n       * method.\n       *\n       * @event Input#closed\n       * @type {Object}\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"closed\"`\n       * @property {Input} target The object that triggered the event\n       */\n      event.type = \"closed\";\n      this.emit(\"closed\", event);\n\n    } else if (e.port.connection === \"closed\" && e.port.state === \"disconnected\") {\n\n      /**\n       * Event emitted when the {@link Input} becomes unavailable. This event is typically fired\n       * when the MIDI device is unplugged.\n       *\n       * @event Input#disconnected\n       * @type {Object}\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"disconnected\"`\n       * @property {Object} target Object with properties describing the {@link Input} that\n       * triggered the event. This is not the actual `Input` as it is no longer available.\n       * @property {string} target.connection `\"closed\"`\n       * @property {string} target.id ID of the input\n       * @property {string} target.manufacturer Manufacturer of the device that provided the input\n       * @property {string} target.name Name of the device that provided the input\n       * @property {string} target.state `\"disconnected\"`\n       * @property {string} target.type `\"input\"`\n       */\n      event.type = \"disconnected\";\n      event.target = {\n        connection: e.port.connection,\n        id: e.port.id,\n        manufacturer: e.port.manufacturer,\n        name: e.port.name,\n        state: e.port.state,\n        type: e.port.type\n      };\n      this.emit(\"disconnected\", event);\n\n    } else if (e.port.connection === \"pending\" && e.port.state === \"disconnected\") {\n      // I don't see the need to forward that...\n    } else {\n      console.warn(\"This statechange event was not caught: \", e.port.connection, e.port.state);\n    }\n\n  }\n\n  /**\n   * Executed when a `\"midimessage\"` event is received\n   * @param e\n   * @private\n   */\n  _onMidiMessage(e) {\n\n    // Extract data bytes (unless it's a sysex message)\n    let dataBytes = null;\n    if (e.data[0] !== WebMidi.MIDI_SYSTEM_MESSAGES.sysex) dataBytes = e.data.slice(1);\n\n    /**\n     * Event emitted when a MIDI message is received on the `Input`\n     *\n     * @event Input#midimessage\n     * @type {Object}\n     * @property {Input} target The `Input` that triggered the event.\n     * @property {Array} event.data The MIDI message as an array of 8 bit values.\n     * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {string} type `\"midimessage\"`\n     * @property {number} event.statusByte The message's status byte.\n     * @property {?number[]} event.dataBytes The message's data bytes as an array of 0, 1 or 2\n     * integers. This will be null for `sysex` messages.\n     *\n     * @since 2.1\n     */\n    let event = {\n      target: this,\n      data: Array.from(e.data),\n      rawData: e.data,\n      statusByte: e.data[0],\n      dataBytes: dataBytes,\n      timestamp: e.timeStamp,\n      type: \"midimessage\"\n    };\n\n    this.emit(\"midimessage\", event);\n\n    // Messages are forwarded to InputChannel if they are channel messages or parsed locally for\n    // system messages.\n    if (e.data[0] < 240) {          // channel-specific message\n      let channel = (e.data[0] & 0xf) + 1;\n      this.channels[channel]._parseEvent(e);\n    } else if (e.data[0] <= 255) {  // system message\n      this._parseEvent(e);\n    }\n\n  }\n\n  /**\n   * @private\n   */\n  _parseEvent(e) {\n\n    let command = e.data[0];\n\n    // Returned event\n    var event = {\n      target: this,\n      data: Array.from(e.data),\n      rawData: e.data,\n      timestamp: e.timeStamp\n    };\n\n    if (command === WebMidi.MIDI_SYSTEM_MESSAGES.sysex) {\n\n      /**\n       * Input-wide (system) event emitted when a **system exclusive** message has been received.\n       * You should note that, to receive `sysex` events, you must call the `WebMidi.enable()`\n       * method with the `sysex` option set to `true`:\n       *\n       * ```js\n       * WebMidi.enable({sysex: true})\n       *  .then(() => console.log(\"WebMidi has been enabled with sysex support.\"))\n       *  .catch(err => console.log(\"WebMidi could not be enabled.\"))\n       * ```\n       *\n       * @event Input#sysex\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"sysex\"`\n       */\n      event.type = \"sysex\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.timecode) {\n\n      /**\n       * Input-wide (system) event emitted when a **time code quarter frame** message has been\n       * received.\n       *\n       * @event Input#timecode\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"sysextimecode\"`\n       */\n      event.type = \"timecode\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.songposition) {\n\n      /**\n       * Input-wide (system) event emitted when a **song position** message has been received.\n       *\n       * @event Input#songposition\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"songposition\"`\n       */\n      event.type = \"songposition\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.songselect) {\n\n      /**\n       * Input-wide (system) event emitted when a **song select** message has been received.\n       *\n       * @event Input#songselect\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"songselect\"`\n       * @property {string} song Song (or sequence) number to select (1-128)\n       */\n      event.type = \"songselect\";\n      event.song = e.data[1] + 1;\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.tunerequest) {\n\n      /**\n       * Input-wide (system) event emitted when a **tune request** message has been received.\n       *\n       * @event Input#tunerequest\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"tunerequest\"`\n       */\n      event.type = \"tunerequest\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.clock) {\n\n      /**\n       * Input-wide (system) event emitted when a **timing clock** message has been received.\n       *\n       * @event Input#clock\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"clock\"`\n       */\n      event.type = \"clock\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.start) {\n\n      /**\n       * Input-wide (system) event emitted when a **start** message has been received.\n       *\n       * @event Input#start\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"start\"`\n       */\n      event.type = \"start\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.continue) {\n\n      /**\n       * Input-wide (system) event emitted when a **continue** message has been received.\n       *\n       * @event Input#continue\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"continue\"`\n       */\n      event.type = \"continue\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.stop) {\n\n      /**\n       * Input-wide (system) event emitted when a **stop** message has been received.\n       *\n       * @event Input#stop\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"stop\"`\n       */\n      event.type = \"stop\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.activesensing) {\n\n      /**\n       * Input-wide (system) event emitted when an **active sensing** message has been received.\n       *\n       * @event Input#activesensing\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"activesensing\"`\n       */\n      event.type = \"activesensing\";\n\n    } else if (command === WebMidi.MIDI_SYSTEM_MESSAGES.reset) {\n\n      /**\n       * Input-wide (system) event emitted when a **reset** message has been received.\n       *\n       * @event Input#reset\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"reset\"`\n       */\n      event.type = \"reset\";\n\n    } else {\n\n      /**\n       * Input-wide (system) event emitted when an unknown MIDI message has been received. It could\n       * be, for example, one of the undefined/reserved messages.\n       *\n       * @event Input#unknownmidimessage\n       * @type {Object}\n       * @property {InputChannel} target The `Input` that triggered the event.\n       * @property {Array} event.data The MIDI message as an array of 8 bit values.\n       * @property {Uint8Array} event.rawData The raw MIDI message as a Uint8Array.\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"unknownmidimessage\"`\n       */\n      event.type = \"unknownmidimessage\";\n\n    }\n\n    this.emit(event.type, event);\n\n  }\n\n  /**\n   * Opens the input for usage.\n   *\n   * @returns {Promise<Input>} The promise is fulfilled with the `Input`\n   */\n  async open() {\n\n    // Explicitly opens the port for usage. This is not mandatory. When the port is not explicitly\n    // opened, it is implicitly opened (asynchronously) when assigning a listener to the\n    // `onmidimessage` property of the `MIDIInput`. We do it explicitly so that 'connected' events\n    // are dispatched immediately and that we are ready to listen.\n    try {\n      await this._midiInput.open();\n      return Promise.resolve(this);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n  }\n\n  /**\n   * Closes the input. When an input is closed, it cannot be used to listen to MIDI messages until\n   * the input is opened again by calling [Input.open()]{@link Input#open}.\n   *\n   * @returns {Promise<void|*>}\n   */\n  async close() {\n\n    // We close the port. This triggers a statechange event which, in turn, will emit the 'closed'\n    // event.\n    if (this._midiInput) {\n      return this._midiInput.close();\n    } else {\n      return Promise.resolve();\n    }\n\n  }\n\n  /**\n   * @private\n   * @deprecated since v3.0.0 (moved to 'InputChannel' class)\n   */\n  getChannelModeByNumber() {\n    if (WebMidi.validation) {\n      console.warn(\n        \"The 'getChannelModeByNumber()' method has been moved to the 'InputChannel' class.\"\n      );\n    }\n  }\n\n  /**\n   * Adds an event listener that will trigger a function callback when the specified event happens.\n   * The event can be **channel-bound** or **input-wide**. Channel-bound events are dispatched by\n   * {@link InputChannel} objects and are tied to a specific MIDI channel while input-wide events\n   * are dispatched by the {@link Input} object itself and are not tied to a specific channel.\n   *\n   * When listening for an input-wide event, you must specify the event to listen for and the\n   * callback function to trigger when the event happens:\n   *\n   * ```\n   * WebMidi.inputs[0].addListener(\"midimessage\", someFunction);\n   * ```\n   *\n   * To listen for a channel-bound event, you must also specify the event to listen for and the\n   * function to trigger but you have to add the channels you wish to listen on in the `options`\n   * parameter:\n   *\n   * ```\n   * WebMidi.inputs[0].addListener(\"noteon\", someFunction, {channels: [1, 2, 3]});\n   * ```\n   *\n   * The code above will add a listener for the `\"noteon\"` event and call `someFunction` when the\n   * event is triggered on MIDI channels `1`, `2` or `3`.\n   *\n   * Note that, when adding events to channels, it is the {@link InputChannel} instance that\n   * actually gets a listener added and not the `{@link Input} instance.\n   *\n   * Note: if you want to add a listener to a single MIDI channel you should probably do so directly\n   * on the {@link InputChannel} object itself.\n   *\n   * There are 6 families of events you can listen to:\n   *\n   * 1. **MIDI System Common** Events (input-wide)\n   *\n   *    * [songposition]{@link Input#event:songposition}\n   *    * [songselect]{@link Input#event:songselect}\n   *    * [sysex]{@link Input#event:sysex}\n   *    * [timecode]{@link Input#event:timecode}\n   *    * [tunerequest]{@link Input#event:tunerequest}\n   *\n   * 2. **MIDI System Real-Time** Events (input-wide)\n   *\n   *    * [clock]{@link Input#event:clock}\n   *    * [start]{@link Input#event:start}\n   *    * [continue]{@link Input#event:continue}\n   *    * [stop]{@link Input#event:stop}\n   *    * [activesensing]{@link Input#event:activesensing}\n   *    * [reset]{@link Input#event:reset}\n   *\n   * 3. **State Change** Events (input-wide)\n   *\n   *    * [opened]{@link Input#event:opened}\n   *    * [closed]{@link Input#event:closed}\n   *    * [disconnected]{@link Input#event:disconnected}\n   *\n   * 4. **Catch-All** Events (input-wide)\n   *\n   *    * [midimessage]{@link Input#event:midimessage}\n   *    * [unknownmidimessage]{@link Input#event:unknownmidimessage}\n   *\n   * 5. **Channel Voice** Events (channel-specific)\n   *\n   *    * [channelaftertouch]{@link InputChannel#event:channelaftertouch}\n   *    * [controlchange]{@link InputChannel#event:controlchange}\n   *    * [keyaftertouch]{@link InputChannel#event:keyaftertouch}\n   *    * [noteoff]{@link InputChannel#event:noteoff}\n   *    * [noteon]{@link InputChannel#event:noteon}\n   *    * [nrpn]{@link InputChannel#event:nrpn}\n   *    * [pitchbend]{@link InputChannel#event:pitchbend}\n   *    * [programchange]{@link InputChannel#event:programchange}\n   *\n   * 6. **Channel Mode** Events (channel-specific)\n   *\n   *    * [channelmode]{@link InputChannel#event:channelmode}\n   *    * To be completed...\n   *\n   * @param event {string} The type of the event.\n   *\n   * @param listener {function} A callback function to execute when the specified event is detected.\n   * This function will receive an event parameter object. For details on this object's properties,\n   * check out the documentation for the various events (links above).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the `arguments` property of the `Listener` object\n   * and can be retrieved or modified as desired.\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of\n   * such integers representing the MIDI channel(s) to listen on. This parameter is ignored for\n   * input-wide events.\n   *\n   * @param {Object} [options.context=this] The value of `this` in the callback function.\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   *\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array.\n   *\n   * @param {boolean} [options.remaining=Infinity] The number of times after which the callback\n   * should automatically be removed.\n   *\n   * @throws {Error} For channel-specific events, 'options.channels' must be defined.\n   *\n   * @returns {Listener[]} An array of all `Listener` objects that were created.\n   */\n  addListener(event, listener, options = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (typeof options === \"function\") {\n        let channels = (listener != undefined) ? [].concat(listener) : undefined; // clone\n        listener = options;\n        options = {channels: channels};\n      }\n\n      // Validation\n      if (\n        WebMidi.MIDI_CHANNEL_VOICE_MESSAGES[event] !== undefined &&\n        options.channels === undefined\n      ) {\n        throw new Error(\"For channel-specific events, 'options.channels' must be defined.\");\n      }\n\n    }\n\n    let listeners = [];\n\n    // Check if the event is channel-specific or input-wide\n    if (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES[event] === undefined) {\n      listeners.push(super.addListener(event, listener, options));\n    } else {\n      Utilities.sanitizeChannels(options.channels).forEach(ch => {\n        listeners.push(this.channels[ch].addListener(event, listener, options));\n      });\n    }\n\n    return listeners;\n\n  }\n\n  /**\n   * Adds a one-time event listener that will trigger a function callback when the specified event\n   * happens. The event can be **channel-bound** or **input-wide**. Channel-bound events are\n   * dispatched by {@link InputChannel} objects and are tied to a specific MIDI channel while\n   * input-wide events are dispatched by the {@link Input} object itself and are not tied to a\n   * specific channel.\n   *\n   * When listening for an input-wide event, you must specify the event to listen for and the\n   * callback function to trigger when the event happens:\n   *\n   * ```\n   * WebMidi.inputs[0].addListener(\"midimessage\", someFunction);\n   * ```\n   *\n   * To listen for a channel-bound event, you must also specify the event to listen for and the\n   * function to trigger but you have to add the channels you wish to listen on in the `options`\n   * parameter:\n   *\n   * ```\n   * WebMidi.inputs[0].addListener(\"noteon\", someFunction, {channels: [1, 2, 3]});\n   * ```\n   *\n   * The code above will add a listener for the `\"noteon\"` event and call `someFunction` when the\n   * event is triggered on MIDI channels `1`, `2` or `3`.\n   *\n   * Note that, when adding events to channels, it is the {@link InputChannel} instance that\n   * actually gets a listener added and not the `{@link Input} instance.\n   *\n   * Note: if you want to add a listener to a single MIDI channel you should probably do so directly\n   * on the {@link InputChannel} object itself.\n   *\n   * There are 6 families of events you can listen to:\n   *\n   * 1. **MIDI System Common** Events (input-wide)\n   *\n   *    * [songposition]{@link Input#event:songposition}\n   *    * [songselect]{@link Input#event:songselect}\n   *    * [sysex]{@link Input#event:sysex}\n   *    * [timecode]{@link Input#event:timecode}\n   *    * [tunerequest]{@link Input#event:tunerequest}\n   *\n   * 2. **MIDI System Real-Time** Events (input-wide)\n   *\n   *    * [clock]{@link Input#event:clock}\n   *    * [start]{@link Input#event:start}\n   *    * [continue]{@link Input#event:continue}\n   *    * [stop]{@link Input#event:stop}\n   *    * [activesensing]{@link Input#event:activesensing}\n   *    * [reset]{@link Input#event:reset}\n   *\n   * 3. **State Change** Events (input-wide)\n   *\n   *    * [opened]{@link Input#event:opened}\n   *    * [closed]{@link Input#event:closed}\n   *    * [disconnected]{@link Input#event:disconnected}\n   *\n   * 4. **Catch-All** Events (input-wide)\n   *\n   *    * [midimessage]{@link Input#event:midimessage}\n   *    * [unknownmidimessage]{@link Input#event:unknownmidimessage}\n   *\n   * 5. **Channel Voice** Events (channel-specific)\n   *\n   *    * [channelaftertouch]{@link InputChannel#event:channelaftertouch}\n   *    * [controlchange]{@link InputChannel#event:controlchange}\n   *    * [keyaftertouch]{@link InputChannel#event:keyaftertouch}\n   *    * [noteoff]{@link InputChannel#event:noteoff}\n   *    * [noteon]{@link InputChannel#event:noteon}\n   *    * [nrpn]{@link InputChannel#event:nrpn}\n   *    * [pitchbend]{@link InputChannel#event:pitchbend}\n   *    * [programchange]{@link InputChannel#event:programchange}\n   *\n   * 6. **Channel Mode** Events (channel-specific)\n   *\n   *    * [channelmode]{@link InputChannel#event:channelmode}\n   *    * To be completed...\n   *\n   * @param event {string} The type of the event.\n   *\n   * @param listener {function} A callback function to execute when the specified event is detected.\n   * This function will receive an event parameter object. For details on this object's properties,\n   * check out the documentation for the various events (links above).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the `arguments` property of the `Listener` object\n   * and can be retrieved or modified as desired.\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of\n   * such integers representing the MIDI channel(s) to listen on. This parameter is ignored for\n   * input-wide events.\n   *\n   * @param {Object} [options.context=this] The value of `this` in the callback function.\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   *\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array.\n   *\n   * @throws {Error} For channel-specific events, 'options.channels' must be defined.\n   *\n   * @returns {Listener[]} An array of all `Listener` objects that were created.\n   */\n  addOneTimeListener(event, listener, options = {}) {\n    options.remaining = 1;\n    return this.addListener(event, listener, options);\n  }\n\n  /**\n   * This is an alias to the [Input.addListener()]{@link Input#addListener} method.\n   * @since 2.0.0\n   * @deprecated since v3.0\n   * @private\n   */\n  on(event, channel, listener, options) {\n    return this.addListener(event, channel, listener, options);\n  }\n\n  /**\n   * Checks if the specified event type is already defined to trigger the listener function. For\n   * channel-specific events, the function will return `true` only if all channels have the listener\n   * defined.\n   *\n   * @param event {string} The type of the event.\n   *\n   * @param listener {function} The callback function to check for.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of\n   * such integers representing the MIDI channel(s) to check. This parameter is ignored for\n   * input-wide events.\n   *\n   * @returns {Boolean} Boolean value indicating whether or not the channel(s) already have this\n   * listener defined.\n   *\n   * @throws Error For channel-specific events, 'options.channels' must be defined.\n   */\n  hasListener(event, listener, options = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (typeof options === \"function\") {\n        let channels = [].concat(listener); // clone\n        listener = options;\n        options = {channels: channels};\n      }\n\n      // Validation\n      if (\n        WebMidi.MIDI_CHANNEL_VOICE_MESSAGES[event] !== undefined &&\n        options.channels === undefined\n      ) {\n        throw new Error(\"For channel-specific events, 'options.channels' must be defined.\");\n      }\n\n    }\n\n    if (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES[event] !== undefined) {\n\n      return Utilities.sanitizeChannels(options.channels).every(ch => {\n        return this.channels[ch].hasListener(event, listener);\n      });\n\n    } else {\n      return super.hasListener(event, listener);\n    }\n\n  }\n\n  /**\n   * Removes the specified listener for the specified event. If no listener is specified, all\n   * listeners for the specified event will be removed. If no event is specified, all listeners for\n   * the `Input` as well as all listeners for all `InputChannels` will be removed.\n   *\n   * By default, channel-specific listeners will be removed from all channels unless the\n   * `options.channel` narrows it down.\n   *\n   * @param [type] {String} The type of the event.\n   *\n   * @param [listener] {Function} The callback function to check for.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of\n   * such integers representing the MIDI channel(s) to match. This parameter is ignored for\n   * input-wide events.\n   *\n   * @param {*} [options.context] Only remove the listeners that have this exact context.\n   *\n   * @param {number} [options.remaining] Only remove the listener if it has exactly that many\n   * remaining times to be executed.\n   */\n  removeListener(event, listener, options = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (typeof options === \"function\") {\n        let channels = [].concat(listener); // clone\n        listener = options;\n        options = {channels: channels};\n      }\n\n    }\n\n    if (options.channels === undefined) {\n      options.channels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n    }\n\n    // If the event is not specified, remove everything (channel-specific and input-wide)!\n    if (event == undefined) {\n      Utilities.sanitizeChannels(\n        options.channels).forEach(ch => this.channels[ch].removeListener()\n      );\n      return super.removeListener();\n    }\n\n    // If the event is specified, check if it's channel-specific or input-wide.\n    if (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES[event] !== undefined) {\n\n      Utilities.sanitizeChannels(options.channels).forEach(ch => {\n        this.channels[ch].removeListener(event, listener, options);\n      });\n\n    } else {\n\n      super.removeListener(event, listener, options);\n\n    }\n\n  }\n\n  /**\n   * Name of the MIDI input\n   *\n   * @type {string}\n   * @readonly\n   */\n  get name() {\n    return this._midiInput.name;\n  }\n\n  /**\n   * ID string of the MIDI port. The ID is host-specific. Do not expect the same ID on different\n   * platforms. For example, Google Chrome and the Jazz-Plugin report completely different IDs for\n   * the same port.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get id() {\n    return this._midiInput.id;\n  }\n\n  /**\n   * Input port's connection state: `\"pending\"`, `\"open\"` or `\"closed\"`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get connection() {\n    return this._midiInput.connection;\n  }\n\n  /**\n   * Name of the manufacturer of the device that makes this input port available.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get manufacturer() {\n    return this._midiInput.manufacturer;\n  }\n\n  /**\n   * An integer to offset the reported octave of incoming notes. By default, middle C (MIDI note\n   * number 60) is placed on the 4th octave (C4).\n   *\n   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If\n   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.\n   *\n   * Note that this value is combined with the global offset value defined on the `WebMidi` object\n   * (if any).\n   *\n   * @type {number}\n   *\n   * @since 3.0\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(value) {\n\n    if (this.validation) {\n      value = parseInt(value);\n      if (isNaN(value)) throw new TypeError(\"The 'octaveOffset' property must be an integer.\");\n    }\n\n    this._octaveOffset = value;\n\n  }\n\n  /**\n   * State of the input port: `\"connected\"` or `\"disconnected\"`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get state() {\n    return this._midiInput.state;\n  }\n\n  /**\n   * Port type. In the case of `Input`, this is always: `\"input\"`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get type() {\n    return this._midiInput.type;\n  }\n\n  /**\n   * @type {boolean}\n   * @private\n   * @deprecated since v3.0.0 (moved to 'InputChannel' class)\n   */\n  get nrpnEventsEnabled() {\n    if (WebMidi.validation) {\n      console.warn(\"The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class.\");\n    }\n    return false;\n  }\n\n}\n","import {EventEmitter} from \"../node_modules/djipevents/dist/djipevents.esm.min.js\";\nimport {WebMidi} from \"./WebMidi.js\";\nimport {Utilities} from \"./Utilities.js\";\n\n/**\n * The `OutputChannel` class represents a single output channel (1-16) from an output device. This\n * object is derived from the host's MIDI subsystem and cannot be instantiated directly.\n *\n * All 16 `OutputChannel` objects can be found inside the output's [channels]{@link Output#channels}\n * property.\n *\n * The `OutputChannel` class extends the\n * [EventEmitter](https://djipco.github.io/djipevents/EventEmitter.html) class from the\n * [djipevents]{@link https://djipco.github.io/djipevents/index.html} module. This means\n * it also includes methods such as\n * [addListener()](https://djipco.github.io/djipevents/EventEmitter.html#addListener),\n * [removeListener()](https://djipco.github.io/djipevents/EventEmitter.html#removeListener),\n * [hasListener()](https://djipco.github.io/djipevents/EventEmitter.html#hasListener) and several\n * others.\n *\n * @param {Output} output The output this channel belongs to\n * @param {number} number The channel's number (1-16)\n *\n * @since 3.0.0\n */\nexport class OutputChannel extends EventEmitter {\n\n  constructor(output, number) {\n\n    super();\n\n    /**\n     * The {@link Output} this channel belongs to\n     * @type {Output}\n     */\n    this.output = output;\n\n    /**\n     * The channel's number (1-16)\n     * @type {number}\n     */\n    this.number = number;\n\n  }\n\n  /**\n   * Unlinks the MIDI subsystem, removes all listeners attached to the channel and nulls the channel\n   * number. This method is mostly for internal use. It has not been prefixed with an underscore\n   * since it is called by other objects such as the `Output` object.\n   *\n   * @private\n   */\n  destroy() {\n    this.output = null;\n    this.number = null;\n    this.removeListener();\n  }\n\n  /**\n   * Sends a MIDI message on the MIDI output port. If no time is specified, the message will be\n   * sent immediately. The message should be an array of 8 bit unsigned integers (0-225) or a\n   * [Uint8Array]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}\n   * object.\n   *\n   * Note that **you cannot use a\n   * [Uint8Array]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}\n   * parameter in the Node.js environment**. This is because the MIDI submodule used in Node.js\n   * ([JZZ.js]{@link https://www.npmjs.com/package/jzz}) does not support it.\n   *\n   * It is usually not necessary to use this method directly as you can use one of the simpler\n   * helper methods such as `playNote()`, `stopNote()`, `sendControlChange()`, etc.\n   *\n   * Details on the format of MIDI messages are available in the summary of\n   * [MIDI messages]{@link https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message}\n   * from the MIDI Manufacturers Association.\n   *\n   * @param message {number[]|Uint8Array} An array of 8bit unsigned integers or a `Uint8Array`\n   * object (not available in Node.js) containing the message bytes. Depending on the type of\n   * message, one to three bytes will be used.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a positive\n   * number\n   * ([DOMHighResTimeStamp]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that point time. If `time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The first byte (status) must be an integer between 128 and 255.\n   *\n   * @throws {RangeError} Data bytes must be integers between 0 and 255.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  send(message, options = {time: 0}) {\n    this.output.send(message, options);\n    return this;\n  }\n\n  /**\n   * Sends a MIDI **key aftertouch** message at the scheduled time. This is a key-specific\n   * aftertouch. For a channel-wide aftertouch message, use\n   * [setChannelAftertouch()]{@link Output#setChannelAftertouch}.\n   *\n   * The note can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *  - A {@link Note} object\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) for which you are sending\n   * an aftertouch value. The notes can be specified by using a MIDI note number (0-127), a note\n   * name (e.g. C3, G#4, F-1, Db7), a {@link Note} object or an array of the previous types. When\n   * using a note name, octave range must be between -1 and 9. The lowest note is C-1 (MIDI note\n   * number 0) and the highest note is G9 (MIDI note number 127).\n   *\n   * @param [pressure=0.5] {number} The pressure level (between 0 and 1). An invalid pressure value\n   * will silently trigger the default behaviour. If the `rawValue` option is set to `true`, the\n   * pressure is defined by using an integer between 0 and 127.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {boolean} [options.useRawValue=false] A boolean indicating whether the value should be\n   * considered a float between 0 and 1.0 (default) or a raw integer between 0 and 127.\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @return {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   * @throws RangeError Invalid key aftertouch value.\n   */\n  setKeyAftertouch(note, pressure, options = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy support\n      if (options.useRawValue) options.rawValue = options.useRawValue;\n\n      if (isNaN(parseFloat(pressure))) {\n        throw new RangeError(\"Invalid key aftertouch value.\");\n      }\n      if (options.rawValue) {\n        if (!(pressure >= 0 && pressure <= 127 && Number.isInteger(pressure))) {\n          throw new RangeError(\"Key aftertouch raw value must be an integer between 0 and 127.\");\n        }\n      } else {\n        if (!(pressure >= 0 && pressure <= 1)) {\n          throw new RangeError(\"Key aftertouch value must be a float between 0 and 1.\");\n        }\n      }\n\n    }\n\n    // Normalize to integer\n    if (!options.rawValue) pressure = Math.round(pressure * 127);\n\n    options.octaveOffset = WebMidi.octaveOffset;\n\n    Utilities.getValidNoteArray(note, options).forEach(n => {\n      this.send(\n        [\n          (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.keyaftertouch << 4) + (this.number - 1),\n          n.number,\n          pressure\n        ],\n        {time: Utilities.convertToTimestamp(options.time)}\n      );\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **control change** message to the channel at the scheduled time. The control\n   * change message to send can be specified numerically (0 to 119) or by using one of the following\n   * common names:\n   *\n   *  * `bankselectcoarse` (#0)\n   *  * `modulationwheelcoarse` (#1)\n   *  * `breathcontrollercoarse` (#2)\n   *  * `footcontrollercoarse` (#4)\n   *  * `portamentotimecoarse` (#5)\n   *  * `dataentrycoarse` (#6)\n   *  * `volumecoarse` (#7)\n   *  * `balancecoarse` (#8)\n   *  * `pancoarse` (#10)\n   *  * `expressioncoarse` (#11)\n   *  * `effectcontrol1coarse` (#12)\n   *  * `effectcontrol2coarse` (#13)\n   *  * `generalpurposeslider1` (#16)\n   *  * `generalpurposeslider2` (#17)\n   *  * `generalpurposeslider3` (#18)\n   *  * `generalpurposeslider4` (#19)\n   *  * `bankselectfine` (#32)\n   *  * `modulationwheelfine` (#33)\n   *  * `breathcontrollerfine` (#34)\n   *  * `footcontrollerfine` (#36)\n   *  * `portamentotimefine` (#37)\n   *  * `dataentryfine` (#38)\n   *  * `volumefine` (#39)\n   *  * `balancefine` (#40)\n   *  * `panfine` (#42)\n   *  * `expressionfine` (#43)\n   *  * `effectcontrol1fine` (#44)\n   *  * `effectcontrol2fine` (#45)\n   *  * `holdpedal` (#64)\n   *  * `portamento` (#65)\n   *  * `sustenutopedal` (#66)\n   *  * `softpedal` (#67)\n   *  * `legatopedal` (#68)\n   *  * `hold2pedal` (#69)\n   *  * `soundvariation` (#70)\n   *  * `resonance` (#71)\n   *  * `soundreleasetime` (#72)\n   *  * `soundattacktime` (#73)\n   *  * `brightness` (#74)\n   *  * `soundcontrol6` (#75)\n   *  * `soundcontrol7` (#76)\n   *  * `soundcontrol8` (#77)\n   *  * `soundcontrol9` (#78)\n   *  * `soundcontrol10` (#79)\n   *  * `generalpurposebutton1` (#80)\n   *  * `generalpurposebutton2` (#81)\n   *  * `generalpurposebutton3` (#82)\n   *  * `generalpurposebutton4` (#83)\n   *  * `reverblevel` (#91)\n   *  * `tremololevel` (#92)\n   *  * `choruslevel` (#93)\n   *  * `celestelevel` (#94)\n   *  * `phaserlevel` (#95)\n   *  * `databuttonincrement` (#96)\n   *  * `databuttondecrement` (#97)\n   *  * `nonregisteredparametercoarse` (#98)\n   *  * `nonregisteredparameterfine` (#99)\n   *  * `registeredparametercoarse` (#100)\n   *  * `registeredparameterfine` (#101)\n   *\n   * Note: as you can see above, not all control change message have a matching common name. This\n   * does not mean you cannot use the others. It simply means you will need to use their number\n   * (0-119) instead of their name. Numbers 120 to 127 are reserved for *channel mode* messages. See\n   * [sendChannelMode()]{@link OutputChannel#sendChannelMode} method for more info.\n   *\n   * To view a detailed list of all available **control change** messages, please consult \"Table 3 -\n   * Control Change Messages\" from the [MIDI Messages](\n   * https://www.midi.org/specifications/item/table-3-control-change-messages-data-bytes-2)\n   * specification.\n   *\n   * @param {number|string} controller The MIDI controller name or number (0-119).\n   *\n   * @param {number} value The value to send (0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {RangeError} Controller numbers must be between 0 and 119.\n   * @throws {RangeError} Invalid controller name.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendControlChange(controller, value, options = {}) {\n\n    if (typeof controller === \"string\") {\n      controller = WebMidi.MIDI_CONTROL_CHANGE_MESSAGES[controller];\n    }\n\n    if (WebMidi.validation) {\n      if (controller === undefined) {\n        throw new TypeError(\n          \"Control change must be identified with a valid name or an integer between 0 and 119.\"\n        );\n      }\n\n      if (!Number.isInteger(controller) || !(controller >= 0 && controller <= 119)) {\n        throw new TypeError(\"Control change number must be an integer between 0 and 119.\");\n      }\n\n      if (!Number.isInteger(value) || !(value >= 0 && value <= 127)) {\n        throw new TypeError(\"Control change value must be an integer between 0 and 127\");\n      }\n    }\n\n    this.send(\n      [\n        (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.controlchange << 4) + (this.number - 1),\n        controller,\n        value\n      ],\n      {time: Utilities.convertToTimestamp(options.time)}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Selects a MIDI non-registered parameter so it is affected by upcoming data entry, data\n   * increment and data decrement messages.\n   *\n   * @param parameter {number[]} A two-position array specifying the two control bytes that identify\n   * the registered parameter. The NRPN MSB (99 or 0x63) is a position 0. The NRPN LSB (98 or 0x62)\n   * is at position 1.\n   *\n   * @private\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _selectNonRegisteredParameter(parameter, options = {}) {\n\n    // parameter[0] = Math.floor(parameter[0]);\n    // if (!(parameter[0] >= 0 && parameter[0] <= 127)) {\n    //   throw new RangeError(\"The control63 value must be between 0 and 127.\");\n    // }\n    //\n    // parameter[1] = Math.floor(parameter[1]);\n    // if (!(parameter[1] >= 0 && parameter[1] <= 127)) {\n    //   throw new RangeError(\"The control62 value must be between 0 and 127.\");\n    // }\n\n    this.sendControlChange(0x63, parameter[0], options);\n    this.sendControlChange(0x62, parameter[1], options);\n\n    return this;\n\n  }\n\n  /**\n   * Deselects the currently active MIDI registered parameter so it is no longer affected by data\n   * entry, data increment and data decrement messages.\n   *\n   * Current best practice recommends doing that after each call to\n   * [_setCurrentParameter()]{@link OutputChannel#_setCurrentParameter}.\n   *\n   * @private\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _deselectRegisteredParameter(options = {}) {\n    this.sendControlChange(0x65, 0x7F, options);\n    this.sendControlChange(0x64, 0x7F, options);\n    return this;\n  }\n\n  /**\n   * Deselects the currently active MIDI non-registered parameter so it is no longer affected by\n   * data entry, data increment and data decrement messages.\n   *\n   * @private\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _deselectNonRegisteredParameter(options = {}) {\n    this.sendControlChange(0x65, 0x7F, options);\n    this.sendControlChange(0x64, 0x7F, options);\n    return this;\n  }\n\n  /**\n   * Selects a MIDI registered parameter so it is affected by upcoming data entry, data increment\n   * and data decrement messages.\n   *\n   * @private\n   *\n   * @param parameter {number[]} A two-position array of integers specifying the two control bytes\n   * (0x65, 0x64) that identify the registered parameter. The integers must be between 0 and 127.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _selectRegisteredParameter(parameter, options = {}) {\n    this.sendControlChange(0x65, parameter[0], options);\n    this.sendControlChange(0x64, parameter[1], options);\n    return this;\n  }\n\n  /**\n   * Sets the value of the currently selected MIDI registered parameter.\n   *\n   * @private\n   *\n   * @param data {number|number[]}\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _setCurrentParameter(data, options = {}) {\n\n    data = [].concat(data);\n\n    // MSB\n    // data[0] = parseInt(data[0]);\n    // if (!isNaN(data[0]) && data[0] >= 0 && data[0] <= 127) {\n    this.sendControlChange(0x06, data[0], options);\n    // } else {\n    //   throw new RangeError(\"The msb value must be between 0 and 127.\");\n    // }\n\n    if (data.length < 2) return this;\n\n    // LSB\n    // data[1] = parseInt(data[1]);\n\n    // if (!isNaN(data[1]) && data[1] >= 0 && data[1] <= 127) {\n    this.sendControlChange(0x26, data[1], options);\n    // } else {\n    //   throw new RangeError(\"The lsb value must be between 0 and 127.\");\n    // }\n\n    return this;\n\n  }\n\n  /**\n   * Decrements the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this function:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `\"pitchbendrange\"`\n   *  * Channel Fine Tuning (0x00, 0x01): `\"channelfinetuning\"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `\"channelcoarsetuning\"`\n   *  * Tuning Program (0x00, 0x03): `\"tuningprogram\"`\n   *  * Tuning Bank (0x00, 0x04): `\"tuningbank\"`\n   *  * Modulation Range (0x00, 0x05): `\"modulationrange\"`\n   *  * Azimuth Angle (0x3D, 0x00): `\"azimuthangle\"`\n   *  * Elevation Angle (0x3D, 0x01): `\"elevationangle\"`\n   *  * Gain (0x3D, 0x02): `\"gain\"`\n   *  * Distance Ratio (0x3D, 0x03): `\"distanceratio\"`\n   *  * Maximum Distance (0x3D, 0x04): `\"maximumdistance\"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `\"maximumdistancegain\"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `\"referencedistanceratio\"`\n   *  * Pan Spread Angle (0x3D, 0x07): `\"panspreadangle\"`\n   *  * Roll Angle (0x3D, 0x08): `\"rollangle\"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws TypeError The specified registered parameter is invalid.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  decrementRegisteredParameter(parameter, options = {}) {\n\n    if (!Array.isArray(parameter)) parameter = WebMidi.MIDI_REGISTERED_PARAMETER[parameter];\n\n    if (WebMidi.validation) {\n      if (parameter === undefined) {\n        throw new TypeError(\"The specified registered parameter is invalid.\");\n      }\n\n      let valid = false;\n\n      Object.getOwnPropertyNames(WebMidi.MIDI_REGISTERED_PARAMETER).forEach(p => {\n        if (\n          WebMidi.MIDI_REGISTERED_PARAMETER[p][0] === parameter[0] &&\n          WebMidi.MIDI_REGISTERED_PARAMETER[p][1] === parameter[1]\n        ) {\n          valid = true;\n        }\n      });\n\n      if (!valid) throw new TypeError(\"The specified registered parameter is invalid.\");\n    }\n\n    this._selectRegisteredParameter(parameter, options);\n    this.sendControlChange(0x61, 0, options);\n    this._deselectRegisteredParameter(options);\n\n    return this;\n\n  }\n\n  /**\n   * Increments the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this function:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `\"pitchbendrange\"`\n   *  * Channel Fine Tuning (0x00, 0x01): `\"channelfinetuning\"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `\"channelcoarsetuning\"`\n   *  * Tuning Program (0x00, 0x03): `\"tuningprogram\"`\n   *  * Tuning Bank (0x00, 0x04): `\"tuningbank\"`\n   *  * Modulation Range (0x00, 0x05): `\"modulationrange\"`\n   *  * Azimuth Angle (0x3D, 0x00): `\"azimuthangle\"`\n   *  * Elevation Angle (0x3D, 0x01): `\"elevationangle\"`\n   *  * Gain (0x3D, 0x02): `\"gain\"`\n   *  * Distance Ratio (0x3D, 0x03): `\"distanceratio\"`\n   *  * Maximum Distance (0x3D, 0x04): `\"maximumdistance\"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `\"maximumdistancegain\"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `\"referencedistanceratio\"`\n   *  * Pan Spread Angle (0x3D, 0x07): `\"panspreadangle\"`\n   *  * Roll Angle (0x3D, 0x08): `\"rollangle\"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws TypeError The specified registered parameter is invalid.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  incrementRegisteredParameter(parameter, options = {}) {\n\n    if (!Array.isArray(parameter)) parameter = WebMidi.MIDI_REGISTERED_PARAMETER[parameter];\n\n    if (WebMidi.validation) {\n      if (parameter === undefined) {\n        throw new TypeError(\"The specified registered parameter is invalid.\");\n      }\n\n      let valid = false;\n\n      Object.getOwnPropertyNames(WebMidi.MIDI_REGISTERED_PARAMETER).forEach(p => {\n        if (\n          WebMidi.MIDI_REGISTERED_PARAMETER[p][0] === parameter[0] &&\n          WebMidi.MIDI_REGISTERED_PARAMETER[p][1] === parameter[1]\n        ) {\n          valid = true;\n        }\n      });\n\n      if (!valid) throw new TypeError(\"The specified registered parameter is invalid.\");\n    }\n\n    this._selectRegisteredParameter(parameter, options);\n    this.sendControlChange(0x60, 0, options);\n    this._deselectRegisteredParameter(options);\n\n    return this;\n\n  }\n\n  /**\n   * Plays a note or an array of notes on the channel. The first parameter is the note to play. It\n   * can be a single value or an array of the following valid values:\n   *\n   *  - A {@link Note} object\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *\n   * The `playNote()` method sends a **note on** MIDI message for all specified notes on all\n   * specified channels. If a `duration` is set in the `options` parameter or in the {@link Note}\n   * object's [duration]{@link Note#duration} property, it will also schedule a **note off** message\n   * to end the note after said duration. If no `duration` is set, the note will simply play until\n   * a matching **note off** message is sent with [stopNote()]{@link OutputChannel#stopNote} or\n   * [sendNoteOff()]{@link OutputChannel#sendNoteOff}.\n   *\n   *  The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using {@link Note} objects, the durations and velocities defined in the {@link Note}\n   * objects have precedence over the ones specified via the method's `options` parameter.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (0-127), a note name (e.g. C3, G#4, F-1, Db7), a\n   * {@link Note} object or an array of the previous types. When using a note name, octave range\n   * must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number} [options.duration] A positive number larger than 0 representing the number of\n   * milliseconds to wait before sending a **note off** message. If invalid or left undefined, only\n   * a **note on** message will be sent.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`). If the `rawAttack` option is also defined, it will have priority. An invalid velocity\n   * value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawAttack=0.5] The attack velocity at which to play the note (between\n   * `0` and `127`). This has priority over the `attack` property. An invalid velocity value will\n   * silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`\n   * and `1`). If the `rawRelease` option is also defined, it will have priority. An invalid\n   * velocity value will silently trigger the default of `0.5`. This is only used with the\n   * **note off** event triggered when `options.duration` is set.\n   *\n   * @param {number} [options.rawRelease=0.5] The velocity at which to release the note (between `0`\n   * and `127`). This has priority over the `release` property. An invalid velocity value will\n   * silently trigger the default of `0.5`. This is only used with the **note off** event triggered\n   * when `options.duration` is set.\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  playNote(note, options = {}) {\n\n    // Send note on and, optionally, note off message (if duration is a positive number)\n    this.sendNoteOn(note, options);\n\n    // https://stackoverflow.com/questions/600763#answer-601877\n    if (options.duration > 0 && isFinite(String(options.duration).trim() || NaN)) {\n\n      let noteOffOptions = {\n        time: (Utilities.convertToTimestamp(options.time) || WebMidi.time) + options.duration,\n        release: options.release,\n        rawRelease: options.rawRelease,\n      };\n\n      this.sendNoteOff(note, noteOffOptions);\n\n    }\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **note off** message for the specified notes on the channel. The first parameter is the\n   * note. It can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *  - A {@link Note} object\n   *\n   *  The execution of the **note off** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using {@link Note} objects, the release velocity defined in the {@link Note} objects has\n   * precedence over the one specified via the method's `options` parameter.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (0-127), a note name (e.g. C3, G#4, F-1, Db7), a\n   * {@link Note} object or an array of the previous types. When using a note name, octave range\n   * must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note\n   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note\n   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `64`.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendNoteOff(note, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (\n        options.rawRelease != undefined &&\n        !(options.rawRelease >= 0 && options.rawRelease <= 127)\n      ) {\n        throw new RangeError(\"The 'rawRelease' option must be an integer between 0 and 127\");\n      }\n\n      if (options.release != undefined && !(options.release >= 0 && options.release <= 1)) {\n        throw new RangeError(\"The 'release' option must be an number between 0 and 1\");\n      }\n\n      // Legacy compatibility warnings\n      if (options.rawVelocity) {\n        options.rawRelease = options.velocity;\n        console.warn(\"The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.\");\n      }\n      if (options.velocity) {\n        options.release = options.velocity;\n        console.warn(\"The 'velocity' option is deprecated. Use 'attack' instead.\");\n      }\n\n    }\n\n    let nVelocity = 64;\n\n    if (options.rawRelease != undefined) {\n      nVelocity = options.rawRelease;\n    } else {\n      if (!isNaN(options.release)) nVelocity = Math.round(options.release * 127);\n    }\n\n    // Send note off messages\n    let o = {rawRelease: parseInt(nVelocity)};\n    o.octaveOffset = WebMidi.octaveOffset;\n\n    Utilities.getValidNoteArray(note, o).forEach(n => {\n      this.send(\n        [\n          (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.noteoff << 4) + (this.number - 1),\n          n.number,\n          n.rawRelease,\n        ],\n        {time: Utilities.convertToTimestamp(options.time)}\n      );\n    });\n\n    return this;\n\n  }\n\n  /**\n   * This is an alias to the [sendNoteOff()]{@link OutputChannel#sendNoteOff} method.\n   *\n   * @see {@link OutputChannel#sendNoteOff}\n   *\n   * @param note\n   * @param options\n   * @returns {Output}\n   */\n  stopNote(note, options = {}) {\n    return this.sendNoteOff(note, options);\n  }\n\n  /**\n   * Sends a **note on** message for the specified note(s) on the channel. The first parameter is\n   * the note. It can be a single value or an array of the following valid values:\n   *\n   *  - A {@link Note} object\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *\n   *  The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using {@link Note} objects, the attack velocity defined in the {@link Note} objects has\n   * precedence over the one specified via the method's `options` parameter. Also, the `duration` is\n   * ignored. If you want to also send a **note off** message, use the\n   * [playNote()]{@link Output#playNote} method instead.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (0-127), a note name (e.g. C3, G#4, F-1, Db7), a\n   * {@link Note} object or an array of the previous types. When using a note name, octave range\n   * must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`).  If the `rawAttack` option is also defined, `rawAttack` will have priority. An invalid\n   * velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawAttack=64] The velocity at which to release the note (between `0`\n   * and `127`). If the `attack` option is also defined, `rawAttack` will have priority. An invalid\n   * velocity value will silently trigger the default of `64`.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendNoteOn(note, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (options.rawAttack != undefined && !(options.rawAttack >= 0 && options.rawAttack <= 127)) {\n        throw new RangeError(\"The 'rawAttack' option must be an integer between 0 and 127\");\n      }\n\n      if (options.attack != undefined && !(options.attack >= 0 && options.attack <= 1)) {\n        throw new RangeError(\"The 'attack' option must be an number between 0 and 1\");\n      }\n\n      // Legacy compatibility warnings\n      if (options.rawVelocity) {\n        options.rawAttack = options.velocity;\n        options.rawRelease = options.release;\n        console.warn(\"The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.\");\n      }\n      if (options.velocity) {\n        options.attack = options.velocity;\n        console.warn(\"The 'velocity' option is deprecated. Use 'attack' instead.\");\n      }\n\n    }\n\n    let nVelocity = 64;\n\n    if (options.rawAttack != undefined) {\n      nVelocity = options.rawAttack;\n    } else {\n      if (!isNaN(options.attack)) nVelocity = Math.round(options.attack * 127);\n    }\n\n    let o = {rawAttack: nVelocity};\n    o.octaveOffset = WebMidi.octaveOffset;\n\n    Utilities.getValidNoteArray(note, o).forEach(n => {\n      this.send(\n        [\n          (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.noteon << 4) + (this.number - 1),\n          n.number,\n          n.rawAttack\n        ],\n        {time: Utilities.convertToTimestamp(options.time)}\n      );\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **channel mode** message. The channel mode message to send can be specified\n   * numerically or by using one of the following common names:\n   *\n   *   * `\"allsoundoff\"` (#120)\n   *   * `\"resetallcontrollers\"` (#121)\n   *   * `\"localcontrol\"` (#122)\n   *   * `\"allnotesoff\"` (#123)\n   *   * `\"omnimodeoff\"` (#124)\n   *   * `\"omnimodeon\"` (#125)\n   *   * `\"monomodeon\"` (#126)\n   *   * `\"polymodeon\"` (#127)\n   *\n   * It should be noted that, per the MIDI specification, only `localcontrol` and `monomodeon` may\n   * require a value that's not zero. For that reason, the `value` parameter is optional and\n   * defaults to 0.\n   *\n   * To make it easier, all channel mode messages have a matching helper method:\n   *\n   *   - [turnSoundOff()]{@link Output#turnSoundOff}\n   *   - [resetAllControllers()]{@link Output#resetAllControllers}\n   *   - [setLocalControl()]{@link Output#turnSoundOff}\n   *   - [turnNotesOff()]{@link Output#turnNotesOff}\n   *   - [setOmniMode()]{@link Output#setOmniMode}\n   *   - [setPolyphonicMode()]{@link Output#setPolyphonicMode}\n   *\n   * @param command {number|string} The numerical identifier of the channel mode message (integer\n   * between 120-127) or its name as a string.\n   *\n   * @param value {number} The value to send (integer between 0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendChannelMode(command, value, options = {}) {\n\n    // Normalize command to integer\n    if (typeof command === \"string\") command = WebMidi.MIDI_CHANNEL_MODE_MESSAGES[command];\n\n    if (WebMidi.validation) {\n\n      if (command === undefined) {\n        throw new TypeError(\"Invalid channel mode message name or number.\");\n      }\n\n      if (isNaN(command) || !(command >= 120 && command <= 127)) {\n        throw new TypeError(\"Invalid channel mode message number.\");\n      }\n\n      if (isNaN(parseInt(value)) || value < 0 || value > 127) {\n        throw new RangeError(\"Value must be an integer between 0 and 127.\");\n      }\n\n    }\n\n    this.send(\n      [\n        (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.channelmode << 4) + (this.number - 1),\n        command,\n        value\n      ],\n      {time: Utilities.convertToTimestamp(options.time)}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sets OMNI mode to `\"on\"` or `\"off\"`. MIDI's OMNI mode causes the instrument to respond to\n   * messages from all channels.\n   *\n   * It should be noted that support for OMNI mode is not as common as it used to be.\n   *\n   * @param [state=true] {boolean} Whether to activate OMNI mode (`true`) or not (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Invalid channel mode message name.\n   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.\n   * @throws {RangeError} Value must be an integer between 0 and 127.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setOmniMode(state, options = {}) {\n\n    if (state === undefined || state) {\n      this.sendChannelMode(\"omnimodeon\", 0, options);\n    } else {\n      this.sendChannelMode(\"omnimodeoff\", 0, options);\n    }\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **channel aftertouch** message. For key-specific aftertouch, you should instead\n   * use [setKeyAftertouch()]{@link Output#setKeyAftertouch}.\n   *\n   * @param [pressure] {number} The pressure level (between 0 and 1). If the `rawValue` option is\n   * set to `true`, the pressure can be defined by using an integer between 0 and 127.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between 0 and 1.0 (default) or a raw integer between 0 and 127.\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   * @throws RangeError Invalid channel aftertouch value.\n   */\n  setChannelAftertouch(pressure, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (isNaN(parseFloat(pressure))) {\n        throw new RangeError(\"Invalid channel aftertouch value.\");\n      }\n\n      if (options.rawValue) {\n        if (!(pressure >= 0 && pressure <= 127 && Number.isInteger(pressure))) {\n          throw new RangeError(\n            \"Channel aftertouch raw value must be an integer between 0 and 127.\")\n          ;\n        }\n      } else {\n        if (!(pressure >= 0 && pressure <= 1)) {\n          throw new RangeError(\"Channel aftertouch value must be a float between 0 and 1.\");\n        }\n      }\n\n    }\n\n    this.send(\n      [\n        (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.channelaftertouch << 4) + (this.number - 1),\n        Math.round(pressure * 127)\n      ],\n      {time: Utilities.convertToTimestamp(options.time)}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **master tuning** message. The value is decimal and must be larger than -65 semitones\n   * and smaller than 64 semitones.\n   *\n   * Because of the way the MIDI specification works, the decimal portion of the value will be\n   * encoded with a resolution of 14bit. The integer portion must be between -64 and 63\n   * inclusively. This function actually generates two MIDI messages: a **Master Coarse Tuning** and\n   * a **Master Fine Tuning** RPN messages.\n   *\n   * @param [value=0.0] {number} The desired decimal adjustment value in semitones (-65 < x < 64)\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller\n   * than 64.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setMasterTuning(value, options = {}) {\n\n    value = parseFloat(value) || 0.0;\n\n    if (WebMidi.validation) {\n\n      if (!(value > -65 && value < 64)) {\n        throw new RangeError(\n          \"The value must be a decimal number larger than -65 and smaller than 64.\"\n        );\n      }\n\n    }\n\n    let coarse = Math.floor(value) + 64;\n    let fine = value - Math.floor(value);\n\n    // Calculate MSB and LSB for fine adjustment (14bit resolution)\n    fine = Math.round((fine + 1) / 2 * 16383);\n    let msb = (fine >> 7) & 0x7F;\n    let lsb = fine & 0x7F;\n\n    this.setRegisteredParameter(\"channelcoarsetuning\", coarse, options);\n    this.setRegisteredParameter(\"channelfinetuning\", [msb, lsb], options);\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **modulation depth range** message to adjust the depth of the modulation wheel's range.\n   * The range can be specified with the `semitones` parameter, the `cents` parameter or by\n   * specifying both parameters at the same time.\n   *\n   * @param {number} semitones The desired adjustment value in semitones (integer between 0 and\n   * 127).\n   *\n   * @param {number} [cents=0] The desired adjustment value in cents (integer between 0 and 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setModulationRange(semitones, cents, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (!Number.isInteger(semitones) || !(semitones >= 0 && semitones <= 127)) {\n        throw new RangeError(\"The semitones value must be an integer between 0 and 127.\");\n      }\n\n      if (!(cents == undefined) && (!Number.isInteger(cents) || !(cents >= 0 && cents <= 127))) {\n        throw new RangeError(\"If specified, the cents value must be an integer between 0 and 127.\");\n      }\n\n    }\n\n    // Default value for cents\n    if (!(cents >= 0 && cents <= 127)) cents = 0;\n\n    this.setRegisteredParameter(\"modulationrange\", [semitones, cents], options);\n\n    return this;\n\n  }\n\n  /**\n   * Sets a non-registered parameter (NRPN) to the specified value. The NRPN is selected by passing\n   * in a two-position array specifying the values of the two control bytes. The value is specified\n   * by passing in a single integer (most cases) or an array of two integers.\n   *\n   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way\n   * they see fit. For example, according to the Roland GS specification, you can control the\n   * **vibrato rate** using NRPN (1, 8). Therefore, to set the **vibrato rate** value to **123** you\n   * would use:\n   *\n   * ```js\n   * WebMidi.outputs[0].channels[0].setNonRegisteredParameter([1, 8], 123);\n   * ```\n   *\n   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you\n   * would use a 2-position array. For example, for its **ClockBPM** parameter (2, 63), Novation\n   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the\n   * value to send was 10, you could use:\n   *\n   * ```js\n   * WebMidi.outputs[0].channels[0].setNonRegisteredParameter([2, 63], [0, 10]);\n   * ```\n   *\n   * For further implementation details, refer to the manufacturer's documentation.\n   *\n   * @param parameter {number[]} A two-position array specifying the two control bytes (0x63,\n   * 0x62) that identify the non-registered parameter.\n   *\n   * @param [data=[]] {number|number[]} An integer or an array of integers with a length of 1 or 2\n   * specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The control value must be between 0 and 127.\n   * @throws {RangeError} The msb value must be between 0 and 127\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setNonRegisteredParameter(nrpn, data, options = {}) {\n\n    data = [].concat(data);\n\n    if (WebMidi.validation) {\n\n      if (!Array.isArray(nrpn) || !Number.isInteger(nrpn[0]) || !Number.isInteger(nrpn[1])) {\n        throw new TypeError(\"The specified NRPN is invalid.\");\n      }\n\n      if (!(nrpn[0] >= 0 && nrpn[0] <= 127)) {\n        throw new RangeError(\"The first byte of the NRPN must be between 0 and 127.\");\n      }\n\n      if (!(nrpn[1] >= 0 && nrpn[1] <= 127)) {\n        throw new RangeError(\"The second byte of the NRPN must be between 0 and 127.\");\n      }\n\n      data.forEach(value => {\n        if (!(value >= 0 && value <= 127)) {\n          throw new RangeError(\"The data bytes of the NRPN must be between 0 and 127.\");\n        }\n      });\n\n    }\n\n    this._selectNonRegisteredParameter(nrpn, options);\n    this._setCurrentParameter(data, options);\n    this._deselectNonRegisteredParameter(options);\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **pitch bend** message at the scheduled time.\n   *\n   * @param {number|number[]} [value] The intensity of the bend (between -1.0 and 1.0). A value of\n   * zero means no bend. The resulting bend is relative to the pitch bend range that has been\n   * defined. The range can be set with [setPitchBendRange()]{@link OutputChannel#setPitchBendRange}\n   * . So, for example, if the pitch bend range has been set to 12 semitones, using a bend value of\n   * -1 will bend the note 1 octave below its nominal value.\n   *\n   * If the `rawValue` option is set to `true`, the intensity of the bend can be defined by either\n   * using a single integer between 0 and 127 (MSB) or an array of two integers between 0 and 127\n   * representing, respectively, the MSB (most significant byte) and the LSB (least significant\n   * byte). The MSB is expressed in semitones with `64` meaning no bend. A value lower than `64`\n   * bends downwards while a value higher than `64` bends upwards. The LSB is expressed in cents\n   * (1/100 of a semitone). An LSB of `64` also means no bend.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered as a float between -1.0 and 1.0 (default) or as raw integer between 0 and 127 (or\n   * an array of 2 integers if using both MSB and LSB).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setPitchBend(value, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (options.rawValue && Array.isArray(value)) {\n\n        if (!(value[0] >= 0 && value[0] <= 127)) {\n          throw new RangeError(\"The pitch bend MSB must be an integer between 0 and 127.\");\n        }\n        if (!(value[1] >= 0 && value[1] <= 127)) {\n          throw new RangeError(\"The pitch bend LSB must be an integer between 0 and 127.\");\n        }\n\n      } else if (options.rawValue && !Array.isArray(value)) {\n\n        if (!(value >= 0 && value <= 127)) {\n          throw new RangeError(\"The pitch bend MSB must be an integer between 0 and 127.\");\n        }\n\n      } else {\n\n        if (isNaN(value) || value === null) {\n          throw new RangeError(\"Invalid pitch bend value.\");\n        }\n\n        if (!(value >= -1 && value <= 1)) {\n          throw new RangeError(\"The pitch bend MSB must be an integer between 0 and 127.\");\n        }\n\n      }\n\n    }\n\n    let msb = 0;\n    let lsb = 0;\n\n    // Calculate MSB and LSB for both scenarios\n    if (options.rawValue && Array.isArray(value)) {\n      msb = value[0];\n      lsb = value[1];\n    } else if (options.rawValue && !Array.isArray(value)) {\n      msb = value;\n    } else {\n      let nLevel = Math.round((value + 1) / 2 * 16383);\n      msb = (nLevel >> 7) & 0x7F;\n      lsb = nLevel & 0x7F;\n    }\n\n    this.send(\n      [\n        (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.pitchbend << 4) + (this.number - 1),\n        lsb,\n        msb\n      ],\n      {time: Utilities.convertToTimestamp(options.time)}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a pitch bend range message to the specified channel(s) at the scheduled time so that they\n   * adjust the range used by their pitch bend lever. The range is specified by using the\n   * `semitones` and `cents` parameters. For example, setting the `semitones` parameter to `12`\n   * means that the pitch bend range will be 12 semitones above and below the nominal pitch.\n   *\n   * @param semitones {number} The desired adjustment value in semitones (between 0 and 127). While\n   * nothing imposes that in the specification, it is very common for manufacturers to limit the\n   * range to 2 octaves (-12 semitones to 12 semitones).\n   *\n   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The msb value must be between 0 and 127.\n   * @throws {RangeError} The lsb value must be between 0 and 127.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setPitchBendRange(semitones, cents, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (!Number.isInteger(semitones) || !(semitones >= 0 && semitones <= 127)) {\n        throw new RangeError(\"The semitones value must be an integer between 0 and 127.\");\n      }\n\n      if (!Number.isInteger(cents) || !(cents >= 0 && cents <= 127)) {\n        throw new RangeError(\"The cents value must be an integer between 0 and 127.\");\n      }\n\n    }\n\n    this.setRegisteredParameter(\"pitchbendrange\", [semitones, cents], options);\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **program change** message at the scheduled time.\n   *\n   * **Note**: since version 3.0, the program number is an integer between 1 and 128. In versions\n   * 1.0 and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices\n   * that use a numbering scheme starting at 1.\n   *\n   * @param [program=1] {number} The MIDI patch (program) number (1-128)\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Failed to execute 'send' on 'MIDIOutput': The value at index 1 is greater\n   * than 0xFF.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   */\n  setProgram(program, options = {}) {\n\n    program = parseInt(program) || 1;\n\n    if (WebMidi.validation) {\n\n      if (!(program >= 1 && program <= 128)) {\n        throw new RangeError(\"The program number must be between 1 and 128.\");\n      }\n\n    }\n\n    this.send(\n      [\n        (WebMidi.MIDI_CHANNEL_VOICE_MESSAGES.programchange << 4) + (this.number - 1),\n        program - 1\n      ],\n      {time: Utilities.convertToTimestamp(options.time)}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sets the specified MIDI registered parameter to the desired value. The value is defined with\n   * up to two bytes of data (msb, lsb) that each can go from 0 to 127.\n   *\n   * MIDI\n   * [registered parameters]\n   * (https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)\n   * extend the original list of control change messages. The MIDI 1.0 specification lists only a\n   * limited number of them. Here are the original registered parameters with the identifier that\n   * can be used as the first parameter of this function:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `\"pitchbendrange\"`\n   *  * Channel Fine Tuning (0x00, 0x01): `\"channelfinetuning\"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `\"channelcoarsetuning\"`\n   *  * Tuning Program (0x00, 0x03): `\"tuningprogram\"`\n   *  * Tuning Bank (0x00, 0x04): `\"tuningbank\"`\n   *  * Modulation Range (0x00, 0x05): `\"modulationrange\"`\n   *\n   * Note that the **Tuning Program** and **Tuning Bank** parameters are part of the *MIDI Tuning\n   * Standard*, which is not widely implemented.\n   *\n   * Another set of extra parameters have been later added for 3D sound controllers. They are:\n   *\n   *  * Azimuth Angle (0x3D, 0x00): `\"azimuthangle\"`\n   *  * Elevation Angle (0x3D, 0x01): `\"elevationangle\"`\n   *  * Gain (0x3D, 0x02): `\"gain\"`\n   *  * Distance Ratio (0x3D, 0x03): `\"distanceratio\"`\n   *  * Maximum Distance (0x3D, 0x04): `\"maximumdistance\"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `\"maximumdistancegain\"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `\"referencedistanceratio\"`\n   *  * Pan Spread Angle (0x3D, 0x07): `\"panspreadangle\"`\n   *  * Roll Angle (0x3D, 0x08): `\"rollangle\"`\n   *\n   * @param parameter {string|number[]} A string identifying the parameter's name (see above) or a\n   * two-position array specifying the two control bytes (e.g. `[0x65, 0x64]`) that identify the\n   * registered parameter.\n   *\n   * @param [data=[]] {number|number[]} An single integer or an array of integers with a maximum\n   * length of 2 specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setRegisteredParameter(rpn, data, options = {}) {\n\n    if (!Array.isArray(rpn)) rpn = WebMidi.MIDI_REGISTERED_PARAMETER[rpn];\n\n    if (WebMidi.validation) {\n\n      if (!Number.isInteger(rpn[0]) || !Number.isInteger(rpn[1])) {\n        throw new TypeError(\"The specified NRPN is invalid.\");\n      }\n\n      if (!(rpn[0] >= 0 && rpn[0] <= 127)) {\n        throw new RangeError(\"The first byte of the RPN must be between 0 and 127.\");\n      }\n\n      if (!(rpn[1] >= 0 && rpn[1] <= 127)) {\n        throw new RangeError(\"The second byte of the RPN must be between 0 and 127.\");\n      }\n\n      [].concat(data).forEach(value => {\n        if (!(value >= 0 && value <= 127)) {\n          throw new RangeError(\"The data bytes of the RPN must be between 0 and 127.\");\n        }\n      });\n\n    }\n\n    this._selectRegisteredParameter(rpn, options);\n    this._setCurrentParameter(data, options);\n    this._deselectRegisteredParameter(options);\n\n    return this;\n\n  }\n\n  /**\n   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * **Note**: since version 3.0, the bank number is an integer between 1 and 128. In versions\n   * 1.0 and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices\n   * that use a numbering scheme starting at 1.\n   *\n   * @param value {number} The desired tuning bank (1-128).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The bank value must be between 1 and 128.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setTuningBank(value, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (!Number.isInteger(value) || !(value >= 1 && value <= 128)) {\n        throw new RangeError(\"The tuning bank number must be between 1 and 128.\");\n      }\n\n    }\n\n    this.setRegisteredParameter(\"tuningbank\", value - 1, options);\n    return this;\n\n  }\n\n  /**\n   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * **Note**: since version 3.0, the program number is an integer between 1 and 128. In versions\n   * 1.0 and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices\n   * that use a numbering scheme starting at 1.\n   *\n   * @param value {number} The desired tuning program (1-128).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The program value must be between 1 and 128.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setTuningProgram(value, options = {}) {\n\n    if (WebMidi.validation) {\n\n      if (!Number.isInteger(value) || !(value >= 1 && value <= 128)) {\n        throw new RangeError(\"The tuning program number must be between 1 and 128.\");\n      }\n\n    }\n\n    this.setRegisteredParameter(\"tuningprogram\", value - 1, options);\n    return this;\n\n  }\n\n  /**\n   * Turns local control on or off. Local control is usually enabled by default. If you disable it,\n   * the instrument will no longer trigger its own sounds. It will only send the MIDI messages to\n   * its out port.\n   *\n   * @param [state=false] {boolean} Whether to activate local control (`true`) or disable it\n   * (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setLocalControl(state, options = {}) {\n    if (state) {\n      return this.sendChannelMode(\"localcontrol\", 127, options);\n    } else {\n      return this.sendChannelMode(\"localcontrol\", 0, options);\n    }\n  }\n\n  /**\n   * Sends an **all notes off** channel mode message. This will make all currently playing notes\n   * fade out just as if their key had been released. This is different from the\n   * [turnSoundOff()]{@link OutputChannel#turnSoundOff} method which mutes all sounds immediately.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  turnNotesOff(options = {}) {\n    return this.sendChannelMode(\"allnotesoff\", 0, options);\n  }\n\n  /**\n   * Sends an **all sound off** channel mode message. This will silence all sounds playing on that\n   * channel but will not prevent new sounds from being triggered.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  turnSoundOff(options = {}) {\n    return this.sendChannelMode(\"allsoundoff\", 0, options);\n  }\n\n  /**\n   * Sends a **reset all controllers** channel mode message. This resets all controllers, such as\n   * the pitch bend, to their default value.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  resetAllControllers(options = {}) {\n    return this.sendChannelMode(\"resetallcontrollers\", 0, options);\n  }\n\n  /**\n   * Sets the polyphonic mode. In `\"poly\"` mode (usually the default), multiple notes can be played\n   * and heard at the same time. In `\"mono\"` mode, only one note will be heard at once even if\n   * multiple notes are being played.\n   *\n   * @param {string} [mode=poly] The mode to use: `\"mono\"` or `\"poly\"`.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [WebMidi.time]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the operation\n   * will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  setPolyphonicMode(mode, options = {}) {\n    if (mode === \"mono\") {\n      return this.sendChannelMode(\"monomodeon\", 0, options);\n    } else {\n      return this.sendChannelMode(\"polymodeon\", 0, options);\n    }\n  }\n\n}\n","import {EventEmitter} from \"../node_modules/djipevents/dist/djipevents.esm.min.js\";\nimport {OutputChannel} from \"./OutputChannel.js\";\nimport {WebMidi} from \"./WebMidi.js\";\nimport {Utilities} from \"./Utilities.js\";\n\n/**\n * The `Output` class represents a MIDI output port. This object is derived from the host's MIDI\n * subsystem and cannot be instantiated directly.\n *\n * You can find a list of all available `Output` objects in the\n * [WebMidi.outputs]{@link WebMidi#outputs} array.\n *\n * The `Output` class extends the\n * [EventEmitter](https://djipco.github.io/djipevents/EventEmitter.html) class from the\n * [djipevents]{@link https://djipco.github.io/djipevents/index.html} module. This means\n * it also includes methods such as\n * [addListener()](https://djipco.github.io/djipevents/EventEmitter.html#addListener),\n * [removeListener()](https://djipco.github.io/djipevents/EventEmitter.html#removeListener),\n * [hasListener()](https://djipco.github.io/djipevents/EventEmitter.html#hasListener) and several\n * others.\n *\n * @param {MIDIOutput} midiOutput `MIDIOutput` object as provided by the MIDI subsystem\n *\n * @fires Output#opened\n * @fires Output#disconnected\n * @fires Output#closed\n */\nexport class Output extends EventEmitter {\n\n  constructor(midiOutput) {\n\n    super();\n\n    if (WebMidi.validation) {\n\n      if (!midiOutput || midiOutput.type !== \"output\") {\n        throw new TypeError(\"The supplied MIDIOutput is invalid.\");\n      }\n\n    }\n\n    /**\n     * A reference to the `MIDIOutput` object\n     * @type {MIDIOutput}\n     * @private\n     */\n    this._midiOutput = midiOutput;\n\n    /**\n     * Array containing the 16 {@link OutputChannel} objects available for this `Output`. The\n     * channels are numbered 1 through 16.\n     *\n     * @type {OutputChannel[]}\n     */\n    this.channels = [];\n    for (let i = 1; i <= 16; i++) this.channels[i] = new OutputChannel(this, i);\n\n    this._midiOutput.onstatechange = this._onStateChange.bind(this);\n\n  }\n\n  /**\n   * Destroys the `Output`. All listeners are removed, all channels are destroyed and the MIDI\n   * subsystem is unlinked.\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    this.removeListener();\n    this.channels.forEach(ch => ch.destroy());\n    this.channels = [];\n    this._midiOutput.onstatechange = null;\n    await this.close();\n    this._midiOutput = null;\n  }\n\n  /**\n   * @private\n   */\n  _onStateChange(e) {\n\n    let event = {\n      timestamp: WebMidi.time\n    };\n\n    if (e.port.connection === \"open\") {\n\n      /**\n       * Event emitted when the {@link Output} has been opened by calling the\n       * [open()]{@link Output#open} method.\n       *\n       * @event Output#opened\n       * @type {Object}\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"opened\"`\n       * @property {Output} target The object that triggered the event\n       */\n      event.type = \"opened\";\n      event.target = this;\n      this.emit(\"opened\", event);\n\n    } else if (e.port.connection === \"closed\" && e.port.state === \"connected\") {\n\n      /**\n       * Event emitted when the {@link Output} has been closed by calling the\n       * [close()]{@link Output#close} method.\n       *\n       * @event Output#closed\n       * @type {Object}\n       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"closed\"`\n       * @property {Output} target The object that triggered the event\n       */\n      event.type = \"closed\";\n      event.target = this;\n      this.emit(\"closed\", event);\n\n    } else if (e.port.connection === \"closed\" && e.port.state === \"disconnected\") {\n\n      /**\n       * Event emitted when the {@link Output} becomes unavailable. This event is typically fired\n       * when the MIDI device is unplugged.\n       *\n       * @event Output#disconnected\n       * @type {Object}\n       * @property {number} timestamp The moment (DOMHighResTimeStamp0 when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {string} type `\"disconnected\"`\n       * @property {Object} target Object with properties describing the {@link Output} that\n       * triggered the event. This is not the actual `Output` as it is no longer available.\n       * @property {string} target.connection `\"closed\"`\n       * @property {string} target.id ID of the input\n       * @property {string} target.manufacturer Manufacturer of the device that provided the input\n       * @property {string} target.name Name of the device that provided the input\n       * @property {string} target.state `\"disconnected\"`\n       * @property {string} target.type `\"output\"`\n       */\n      event.type = \"disconnected\";\n      event.target = {\n        connection: e.port.connection,\n        id: e.port.id,\n        manufacturer: e.port.manufacturer,\n        name: e.port.name,\n        state: e.port.state,\n        type: e.port.type\n      };\n      this.emit(\"disconnected\", event);\n\n    } else if (e.port.connection === \"pending\" && e.port.state === \"disconnected\") {\n      // I don't see the need to forward that...\n    } else {\n      console.warn(\"This statechange event was not caught:\", e.port.connection, e.port.state);\n    }\n\n  }\n\n  /**\n   * Opens the output for usage.\n   *\n   * @returns {Promise<Output>} The promise is fulfilled with the `Output`\n   */\n  async open() {\n\n    // Explicitly opens the port for usage. This is not mandatory. When the port is not explicitly\n    // opened, it is implicitly opened (asynchronously) when calling `send()` on the `MIDIOutput`.\n    // We do it explicitly so that 'connected' events are dispatched immediately and we are ready to\n    // send.\n    try {\n      await this._midiOutput.open();\n      return Promise.resolve(this);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n  }\n\n  /**\n   * Closes the output connection. When an output is closed, it cannot be used to send MIDI messages\n   * until the output is opened again by calling [Output.open()]{@link Output#open}. You can check\n   * the connection status by looking at the [connection]{@link Output#connection} property.\n   *\n   * @returns {Promise<void>}\n   */\n  async close() {\n\n    // We close the port. This triggers a 'statechange' event which we listen to to re-trigger the\n    // 'closed' event.\n    if (this._midiOutput) {\n      await this._midiOutput.close();\n    } else {\n      await Promise.resolve();\n    }\n\n  }\n\n  /**\n   * Sends a MIDI message on the MIDI output port. If no time is specified, the message will be\n   * sent immediately. The message should be an array of 8 bit unsigned integers (0-225) or a\n   * [Uint8Array]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}\n   * object.\n   *\n   * Note that **you cannot use a\n   * [Uint8Array]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}\n   * parameter in the Node.js environment**. This is because the MIDI submodule used in Node.js\n   * ([JZZ.js]{@link https://www.npmjs.com/package/jzz}) does not support it.\n   *\n   * It is usually not necessary to use this method directly as you can use one of the simpler\n   * helper methods such as [playNote()`, `stopNote()`, `sendControlChange()`, etc.\n   *\n   * Details on the format of MIDI messages are available in the summary of\n   * [MIDI messages]{@link https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message}\n   * from the MIDI Manufacturers Association.\n   *\n   * @param message {number[]|Uint8Array} An array of 8bit unsigned integers or a `Uint8Array`\n   * object (not available in Node.js) containing the message bytes. Depending on the type of\n   * message, one to three bytes will be used.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a positive\n   * number\n   * ([DOMHighResTimeStamp]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that point time. If `time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The first byte (status) must be an integer between 128 and 255.\n   *\n   * @throws {RangeError} Data bytes must be integers between 0 and 255.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  send(message, options = {time: 0}, legacy = undefined) {\n\n    if (WebMidi.validation) {\n\n      // If message is neither an array nor a Uint8Array, then we are in legacy mode\n      if (!Array.isArray(message) && !(message instanceof Uint8Array)) {\n        message = [message];\n        if (Array.isArray(options)) message = message.concat(options);\n        options = legacy ? {time: legacy} : {time: 0};\n      }\n\n      if (!(parseInt(message[0]) >= 128 && parseInt(message[0]) <= 255)) {\n        throw new RangeError(\"The first byte (status) must be an integer between 128 and 255.\");\n      }\n\n      message.slice(1).forEach(value => {\n        value = parseInt(value);\n        if (!(value >= 0 && value <= 255)) {\n          throw new RangeError(\"Data bytes must be integers between 0 and 255.\");\n        }\n      });\n\n      if (!options) options = {time: 0};\n\n    }\n\n    // Send message and return `Output` for chaining\n    this._midiOutput.send(message, Utilities.convertToTimestamp(options.time));\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI [system exclusive]{@link\n    * https://www.midi.org/specifications-old/item/table-4-universal-system-exclusive-messages}\n   * (*sysex*) message. The generated message will automatically be prepended with the *sysex byte*\n   * (0xF0) and terminated with the *end of sysex byte* (0xF7).\n   *\n   * To use the `sendSysex()` method, system exclusive message support must have been enabled. To\n   * do so, you must set the `sysex` option to `true` when calling `WebMidi.enable()`:\n   *\n   * ```js\n   * WebMidi.enable({sysex: true})\n   *   .then(() => console.log(\"System exclusive messages are enabled\");\n   * ```\n   *\n   * Note that, depending on browser, version and platform, it is generally necessary to serve the\n   * page over HTTPS to enable sysex support.\n   *\n   * ##### Examples\n   *\n   * If you want to send a sysex message to a Korg device connected to the first output, you would\n   * use the following code:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex(0x42, [0x1, 0x2, 0x3, 0x4, 0x5]);\n   * ```\n   *\n   * The parameters can be specified using any number notation (decimal, hex, binary, etc.).\n   * Therefore, the code below is equivalent to the code above:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex(66, [1, 2, 3, 4, 5]);\n   * ```\n   *\n   * The above code sends the byte values 1, 2, 3, 4 and 5 to Korg devices (hex 42 is the same as\n   * decimal 66).\n   *\n   * Some manufacturers are identified using 3 bytes. In this case, you would use a 3-position array\n   * as the first parameter. For example, to send the same sysex message to a\n   * *Native Instruments* device:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex([0x00, 0x21, 0x09], [0x1, 0x2, 0x3, 0x4, 0x5]);\n   * ```\n   * There is no limit for the length of the data array. However, it is generally suggested to keep\n   * system exclusive messages to 64Kb or less.\n   *\n   * @param manufacturer {number|number[]} An unsigned integer or an array of three unsigned\n   * integers between 0 and 127 that identify the targeted manufacturer. The *MIDI Manufacturers\n   * Association* maintains a full list of\n   * [Manufacturer ID Numbers](https://www.midi.org/specifications-old/item/manufacturer-id-numbers)\n   * .\n   *\n   * @param [data=number[]] {Array} An array of unsigned integers between 0 and 127. This is the\n   * data you wish to transfer.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {DOMException} Failed to execute 'send' on 'MIDIOutput': System exclusive message is\n   * not allowed.\n   *\n   * @throws {TypeError} Failed to execute 'send' on 'MIDIOutput': The value at index x is greater\n   * than 0xFF.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendSysex(manufacturer, data, options = {}) {\n\n    // Merging Uint8Arrays\n    // var arrayOne = new Uint8Array([2,4,8]);\n    // var arrayTwo = new Uint8Array([16,32,64]);\n    //\n    // var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n    // mergedArray.set(arrayOne);\n    // mergedArray.set(arrayTwo, arrayOne.length);\n\n    manufacturer = [].concat(manufacturer);\n\n    data = manufacturer.concat(data, WebMidi.MIDI_SYSTEM_MESSAGES.sysexend);\n    this.send([WebMidi.MIDI_SYSTEM_MESSAGES.sysex].concat(data), {time: options.time});\n\n    return this;\n\n  };\n\n  /**\n   * Clears all messages that have been queued but not yet delivered.\n   *\n   * Warning: this method has been defined in the specification but has not been implemented yet. As\n   * soon as browsers implement it, it will work.\n   *\n   * You can check out the current status of this feature for Chromium (Chrome) here:\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=471798\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  clear() {\n\n    if (this._midiOutput.clear) {\n\n      this._midiOutput.clear();\n\n    } else {\n\n      if (WebMidi.validation) {\n        console.warn(\n          \"The 'clear()' method has not yet been implemented in your environment.\"\n        );\n      }\n\n    }\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **timecode quarter frame** message. Please note that no processing is being done\n   * on the data. It is up to the developer to format the data according to the\n   * [MIDI Timecode](https://en.wikipedia.org/wiki/MIDI_timecode) format.\n   *\n   * @param value {number} The quarter frame message content (integer between 0 and 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendTimecodeQuarterFrame(value, options = {}) {\n\n    if (WebMidi.validation) {\n      value = parseInt(value);\n      if (isNaN(value) || !(value >= 0 && value <= 127)) {\n        throw new RangeError(\"The value must be an integer between 0 and 127.\");\n      }\n    }\n\n    this.send(\n      [\n        WebMidi.MIDI_SYSTEM_MESSAGES.timecode,\n        value\n      ],\n      {time: options.time}\n    );\n\n    return this;\n\n  };\n\n  /**\n   * Sends a **ong position** MIDI message. The value is expressed in MIDI beats (between 0 and\n   * 16383) which are 16th note. Position 0 is always the start of the song.\n   *\n   * @param [value=0] {number} The MIDI beat to cue to (integer between 0 and 16383).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setSongPosition(value, options = {}) {\n\n    value = Math.floor(value) || 0;\n\n    var msb = (value >> 7) & 0x7F;\n    var lsb = value & 0x7F;\n\n    this.send(\n      [\n        WebMidi.MIDI_SYSTEM_MESSAGES.songposition,\n        msb,\n        lsb\n      ],\n      {time: options.time}\n    );\n    return this;\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendSongPosition(value, options = {}) {\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendSongPosition() method has been deprecated. Use setSongPosition() instead.\"\n      );\n    }\n\n    return this.setSongPosition(value, options);\n\n  }\n\n  /**\n   * Sends a **song select** MIDI message.\n   *\n   * **Note**: since version 3.0, the song number is an integer between 1 and 128. In versions 1.0\n   * and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices that\n   * use a numbering scheme starting at 1.\n   *\n   * @param value {number} The number of the song to select (integer between 1 and 128).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws The song number must be between 1 and 128.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setSong(value, options = {}) {\n\n    if (WebMidi.validation) {\n\n      value = parseInt(value);\n\n      if (isNaN(value) || !(value >= 1 && value <= 128)) {\n        throw new RangeError(\"The program value must be between 1 and 128\");\n      }\n\n    }\n\n    this.send(\n      [\n        WebMidi.MIDI_SYSTEM_MESSAGES.songselect,\n        value\n      ],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendSongSelect(value, options = {}) {\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendSongSelect() method has been deprecated. Use setSong() instead.\"\n      );\n    }\n\n    return this.setSong(value, options);\n\n  }\n\n  /**\n   * Sends a MIDI **tune request** real-time message.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendTuneRequest(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.tunerequest],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **clock* real-time message. According to the standard, there are 24 MIDI Clocks\n   * for every quarter note.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendClock(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.clock],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **start** real-time message. A MIDI Start message starts the playback of the current\n   * song at beat 0. To start playback elsewhere in the song, use the\n   * [sendContinue()]{@link Output#sendContinue} method.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendStart(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.start],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **continue** real-time message. This resumes song playback where it was previously\n   * stopped or where it was last cued with a song position message. To start playback from the\n   * start, use the [sendStart()]{@link Output#sendStart}` method.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendContinue(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.continue],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **stop** real-time message. This tells the device connected to this output to stop\n   * playback immediately (or at the scheduled time).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendStop(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.stop],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends an **active sensing** real-time message. This tells the device connected to this port\n   * that the connection is still good. Active sensing messages should be sent every 300 ms if there\n   * was no other activity on the MIDI port.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendActiveSensing(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.activesensing],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **reset** real-time message. This tells the device connected to this output that it\n   * should reset itself to a default state.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendReset(options = {}) {\n\n    this.send(\n      [WebMidi.MIDI_SYSTEM_MESSAGES.reset],\n      {time: options.time}\n    );\n\n    return this;\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendTuningRequest(options = {}) {\n\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead.\"\n      );\n    }\n\n    return this.sendTuneRequest(options);\n\n  }\n\n  /**\n   * Sends a MIDI **key aftertouch** message to the specified channel(s) at the scheduled time. This\n   * is a key-specific aftertouch. For a channel-wide aftertouch message, use\n   * [setChannelAftertouch()]{@link Output#setChannelAftertouch}.\n   *\n   * @param note {number|string|Array}  The note for which you are sending an aftertouch value. The\n   * notes can be specified in one of two ways. The first way is by using the MIDI note number (an\n   * integer between 0 and 127). The second way is by using the note name followed by the octave\n   * (C3, G#4, F-1, Db7). The octave range should be between -1 and 9. The lowest note is C-1 (MIDI\n   * note number 0) and the highest note is G9 (MIDI note number 127). It is also possible to use\n   * an array of note names and/or numbers.\n   *\n   * @param [pressure=0.5] {number} The pressure level (between 0 and 1). An invalid pressure value\n   * will silently trigger the default behaviour. If the `rawValue` option is set to `true`, the\n   * pressure can be defined by using an integer between 0 and 127.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between 0 and 1.0 (default) or a raw integer between 0 and 127.\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setKeyAftertouch(note, pressure, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(pressure) || Number.isInteger(pressure) || pressure === \"all\") {\n        let channels = pressure;\n        pressure = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setKeyAftertouch(note, pressure, options);\n    });\n\n    return this;\n\n  };\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendKeyAftertouch(note, channel, pressure, options = {}) {\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendKeyAftertouch() method has been deprecated. Use setKeyAftertouch() instead.\"\n      );\n    }\n\n    options.channels = channel;\n    return this.setKeyAftertouch(note, pressure, options);\n\n  }\n\n  /**\n   * Sends a MIDI **control change** message to the specified channel(s) at the scheduled time. The\n   * control change message to send can be specified numerically or by using one of the following\n   * common names:\n   *\n   *  * `bankselectcoarse` (#0)\n   *  * `modulationwheelcoarse` (#1)\n   *  * `breathcontrollercoarse` (#2)\n   *  * `footcontrollercoarse` (#4)\n   *  * `portamentotimecoarse` (#5)\n   *  * `dataentrycoarse` (#6)\n   *  * `volumecoarse` (#7)\n   *  * `balancecoarse` (#8)\n   *  * `pancoarse` (#10)\n   *  * `expressioncoarse` (#11)\n   *  * `effectcontrol1coarse` (#12)\n   *  * `effectcontrol2coarse` (#13)\n   *  * `generalpurposeslider1` (#16)\n   *  * `generalpurposeslider2` (#17)\n   *  * `generalpurposeslider3` (#18)\n   *  * `generalpurposeslider4` (#19)\n   *  * `bankselectfine` (#32)\n   *  * `modulationwheelfine` (#33)\n   *  * `breathcontrollerfine` (#34)\n   *  * `footcontrollerfine` (#36)\n   *  * `portamentotimefine` (#37)\n   *  * `dataentryfine` (#38)\n   *  * `volumefine` (#39)\n   *  * `balancefine` (#40)\n   *  * `panfine` (#42)\n   *  * `expressionfine` (#43)\n   *  * `effectcontrol1fine` (#44)\n   *  * `effectcontrol2fine` (#45)\n   *  * `holdpedal` (#64)\n   *  * `portamento` (#65)\n   *  * `sustenutopedal` (#66)\n   *  * `softpedal` (#67)\n   *  * `legatopedal` (#68)\n   *  * `hold2pedal` (#69)\n   *  * `soundvariation` (#70)\n   *  * `resonance` (#71)\n   *  * `soundreleasetime` (#72)\n   *  * `soundattacktime` (#73)\n   *  * `brightness` (#74)\n   *  * `soundcontrol6` (#75)\n   *  * `soundcontrol7` (#76)\n   *  * `soundcontrol8` (#77)\n   *  * `soundcontrol9` (#78)\n   *  * `soundcontrol10` (#79)\n   *  * `generalpurposebutton1` (#80)\n   *  * `generalpurposebutton2` (#81)\n   *  * `generalpurposebutton3` (#82)\n   *  * `generalpurposebutton4` (#83)\n   *  * `reverblevel` (#91)\n   *  * `tremololevel` (#92)\n   *  * `choruslevel` (#93)\n   *  * `celestelevel` (#94)\n   *  * `phaserlevel` (#95)\n   *  * `databuttonincrement` (#96)\n   *  * `databuttondecrement` (#97)\n   *  * `nonregisteredparametercoarse` (#98)\n   *  * `nonregisteredparameterfine` (#99)\n   *  * `registeredparametercoarse` (#100)\n   *  * `registeredparameterfine` (#101)\n   *\n   * Note: as you can see above, not all control change message have a matching common name. This\n   * does not mean you cannot use the others. It simply means you will need to use their number\n   * (0-119) instead of their name. Numbers 120 to 127 are reserved for *channel mode* messages. See\n   * [sendChannelMode()]{@link Output#sendChannelMode} method for more info.\n   *\n   * To view a list of all available `control change` messages, please consult \"Table 3 - Control\n   * Change Messages\" from the [MIDI Messages](\n   * https://www.midi.org/specifications/item/table-3-control-change-messages-data-bytes-2)\n   * specification.\n   *\n   * @param controller {number|string} The MIDI controller name or number (0-119).\n   *\n   * @param [value=0] {number} The value to send (0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} Controller numbers must be between 0 and 119.\n   * @throws {RangeError} Invalid controller name.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendControlChange(controller, value, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].sendControlChange(controller, value, options);\n    });\n\n    return this;\n\n  };\n\n  /**\n   * Sends a pitch bend range message to the specified channel(s) at the scheduled time so that they\n   * adjust the range used by their pitch bend lever. The range is specified by using the\n   * `semitones` and `cents` parameters. For example, setting the `semitones` parameter to `12`\n   * means that the pitch bend range will be 12 semitones above and below the nominal pitch.\n   *\n   * @param semitones {number} The desired adjustment value in semitones (between 0 and 127). While\n   * nothing imposes that in the specification, it is very common for manufacturers to limit the\n   * range to 2 octaves (-12 semitones to 12 semitones).\n   *\n   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The msb value must be between 0 and 127.\n   * @throws {RangeError} The lsb value must be between 0 and 127.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setPitchBendRange(semitones, cents, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setPitchBendRange(semitones, cents, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sets the specified MIDI registered parameter to the desired value. The value is defined with\n   * up to two bytes of data (msb, lsb) that each can go from 0 to 127.\n   *\n   * MIDI\n   * [registered parameters]\n   * (https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)\n   * extend the original list of control change messages. The MIDI 1.0 specification lists only a\n   * limited number of them. Here are the original registered parameters with the identifier that\n   * can be used as the first parameter of this function:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `\"pitchbendrange\"`\n   *  * Channel Fine Tuning (0x00, 0x01): `\"channelfinetuning\"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `\"channelcoarsetuning\"`\n   *  * Tuning Program (0x00, 0x03): `\"tuningprogram\"`\n   *  * Tuning Bank (0x00, 0x04): `\"tuningbank\"`\n   *  * Modulation Range (0x00, 0x05): `\"modulationrange\"`\n   *\n   * Note that the **Tuning Program** and **Tuning Bank** parameters are part of the *MIDI Tuning\n   * Standard*, which is not widely implemented.\n   *\n   * Another set of extra parameters have been later added for 3D sound controllers. They are:\n   *\n   *  * Azimuth Angle (0x3D, 0x00): `\"azimuthangle\"`\n   *  * Elevation Angle (0x3D, 0x01): `\"elevationangle\"`\n   *  * Gain (0x3D, 0x02): `\"gain\"`\n   *  * Distance Ratio (0x3D, 0x03): `\"distanceratio\"`\n   *  * Maximum Distance (0x3D, 0x04): `\"maximumdistance\"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `\"maximumdistancegain\"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `\"referencedistanceratio\"`\n   *  * Pan Spread Angle (0x3D, 0x07): `\"panspreadangle\"`\n   *  * Roll Angle (0x3D, 0x08): `\"rollangle\"`\n   *\n   * @param parameter {string|number[]} A string identifying the parameter's name (see above) or a\n   * two-position array specifying the two control bytes (e.g. `[0x65, 0x64]`) that identify the\n   * registered parameter.\n   *\n   * @param [data=[]] {number|number[]} A single integer or an array of integers with a maximum\n   * length of 2 specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  setRegisteredParameter(parameter, data, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setRegisteredParameter(parameter, data, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends a MIDI **channel aftertouch** message to the specified channel(s). For key-specific\n   * aftertouch, you should instead use [setKeyAftertouch()]{@link Output#setKeyAftertouch}.\n   *\n   * @param [pressure=0.5] {number} The pressure level (between 0 and 1). An invalid pressure value\n   * will silently trigger the default behaviour. If the `rawValue` option is set to `true`, the\n   * pressure can be defined by using an integer between 0 and 127.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between 0 and 1.0 (default) or a raw integer between 0 and 127.\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   * @since 3.0.0\n   */\n  setChannelAftertouch(pressure, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setChannelAftertouch(pressure, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendChannelAftertouch(pressure, channel, options = {}) {\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendChannelAftertouch() method has been deprecated. Use setChannelAftertouch().\"\n      );\n    }\n\n    options.channels = channel;\n    return this.setChannelAftertouch(pressure, options);\n\n  }\n\n  /**\n   * Sends a MIDI **pitch bend** message to the specified channel(s) at the scheduled time.\n   *\n   * @param {number|number[]} value The intensity of the bend (between -1.0 and 1.0). A value of\n   * zero means no bend. The resulting bend is relative to the pitch bend range that has been\n   * defined. The range can be set with [setPitchBendRange()]{@link OutputChannel#setPitchBendRange}\n   * . So, for example, if the pitch bend range has been set to 12 semitones, using a bend value of\n   * -1 will bend the note 1 octave below its nominal value.\n   *\n   * If an invalid value is specified, the nearest valid value will be used instead.\n   *\n   * If the `rawValue` option is set to `true`, the intensity of the bend can be defined by either\n   * using a single integer between 0 and 127 (MSB) or an array of two integers between 0 and 127\n   * representing, respectively, the MSB (most significant byte) and the LSB (least significant\n   * byte). The MSB is expressed in semitones with `64` meaning no bend. A value lower than `64`\n   * bends downwards while a value higher than `64` bends upwards. The LSB is expressed in cents\n   * (1/100 of a semitone). An LSB of `64` also means no bend.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered as a float between -1.0 and 1.0 (default) or as raw integer between 0 and 127 (or\n   * an array of 2 integers if using both MSB and LSB).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setPitchBend(value, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setPitchBend(value, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendPitchBend(bend, channel, options = {}) {\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendPitchBend() method has been deprecated. Use setPitchBend() instead.\"\n      );\n    }\n\n    options.channels = channel;\n    return this.setPitchBend(bend, options);\n\n  }\n\n  /**\n   * Sends a MIDI **program change** message to the specified channel(s) at the scheduled time.\n   *\n   * **Note**: since version 3.0, the program number is an integer between 1 and 128. In versions\n   * 1.0 and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices\n   * that use a numbering scheme starting at 1.\n   *\n   * @param [program=1] {number} The MIDI patch (program) number (1-128)\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Failed to execute 'send' on 'MIDIOutput': The value at index 1 is greater\n   * than 0xFF.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setProgram(program, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setProgram(program, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendProgramChange(program, channel, options = {}) {\n\n    if (WebMidi.validation) {\n      console.warn(\n        \"The sendProgramChange() method has been deprecated. Use setProgram() instead.\"\n      );\n    }\n\n    options.channels = channel;\n    return this.setProgram(program, options);\n\n  }\n\n  /**\n   * Sends a **modulation depth range** message to the specified channel(s) so that they adjust the\n   * depth of their modulation wheel's range. The range can be specified with the `semitones`\n   * parameter, the `cents` parameter or by specifying both parameters at the same time.\n   *\n   * @param [semitones=0] {number} The desired adjustment value in semitones (integer between\n   * 0 and 127).\n   *\n   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0 and 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The msb value must be between 0 and 127\n   * @throws {RangeError} The lsb value must be between 0 and 127\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setModulationRange(semitones, cents, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setModulationRange(semitones, cents, options);\n    });\n\n    return this;\n\n  };\n\n  /**\n   * Sends a master tuning message to the specified channel(s). The value is decimal and must be\n   * larger than -65 semitones and smaller than 64 semitones.\n   *\n   * Because of the way the MIDI specification works, the decimal portion of the value will be\n   * encoded with a resolution of 14bit. The integer portion must be between -64 and 63\n   * inclusively. This function actually generates two MIDI messages: a **Master Coarse Tuning** and\n   * a **Master Fine Tuning** RPN messages.\n   *\n   * @param [value=0.0] {number} The desired decimal adjustment value in semitones (-65 < x < 64)\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller\n   * than 64.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setMasterTuning(value, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setMasterTuning(value, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * **Note**: since version 3.0, the program number is an integer between 1 and 128. In versions\n   * 1.0 and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices\n   * that use a numbering scheme starting at 1.\n   *\n   * @param value {number} The desired tuning program (1-128).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The program value must be between 1 and 128.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setTuningProgram(value, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setTuningProgram(value, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * **Note**: since version 3.0, the bank number is an integer between 1 and 128. In versions\n   * 1.0 and 2.0, the number was between 0 and 127. This change aligns WebMidi.js with most devices\n   * that use a numbering scheme starting at 1.\n   *\n   * @param value {number} The desired tuning bank (1-128).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The bank value must be between 1 and 128.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setTuningBank(value, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    WebMidi.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setTuningBank(value, options);\n    });\n\n    return this;\n\n  };\n\n  /**\n   * Sends a MIDI **channel mode** message to the specified channel(s). The channel mode message to\n   * send can be specified numerically or by using one of the following common names:\n   *\n   *   * `\"allsoundoff\"` (#120)\n   *   * `\"resetallcontrollers\"` (#121)\n   *   * `\"localcontrol\"` (#122)\n   *   * `\"allnotesoff\"` (#123)\n   *   * `\"omnimodeoff\"` (#124)\n   *   * `\"omnimodeon\"` (#125)\n   *   * `\"monomodeon\"` (#126)\n   *   * `\"polymodeon\"` (#127)\n   *\n   * It should be noted that, per the MIDI specification, only `localcontrol` and `monomodeon` may\n   * require a value that's not zero. For that reason, the `value` parameter is optional and\n   * defaults to 0.\n   *\n   * To make it easier, all channel mode messages have a matching helper method:\n   *\n   *   - [turnSoundOff()]{@link OutputChannel#turnSoundOff}\n   *   - [resetAllControllers()]{@link OutputChannel#resetAllControllers}\n   *   - [setLocalControl()]{@link OutputChannel#turnSoundOff}\n   *   - [turnNotesOff()]{@link OutputChannel#turnNotesOff}\n   *   - [setOmniMode()]{@link OutputChannel#setOmniMode}\n   *   - [setPolyphonicMode()]{@link OutputChannel#setPolyphonicMode}\n   *\n   * @param command {number|string} The numerical identifier of the channel mode message (integer\n   * between 120-127) or its name as a string.\n   *\n   * @param [value] {number} The value to send (integer between 0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Invalid channel mode message name.\n   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.\n   * @throws {RangeError} Value must be an integer between 0 and 127.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   */\n  sendChannelMode(command, value, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].sendChannelMode(command, value, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends an **all sound off** channel mode message. This will silence all sounds playing on that\n   * channel but will not prevent new sounds from being triggered.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output}\n   *\n   * @since 3.0.0\n   */\n  turnSoundOff(options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].turnSoundOff(options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends an **all notes off** channel mode message. This will make all currently playing notes\n   * fade out just as if their key had been released. This is different from the\n   * [turnSoundOff()]{@link Output#turnSoundOff} method which mutes all sounds immediately.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output}\n   *\n   * @since 3.0.0\n   */\n  turnNotesOff(options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].turnNotesOff(options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **reset all controllers** channel mode message. This resets all controllers, such as\n   * the pitch bend, to their default value.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output}\n   */\n  resetAllControllers(options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].resetAllControllers(options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sets the polyphonic mode. In `\"poly\"` mode (usually the default), multiple notes can be played\n   * and heard at the same time. In `\"mono\"` mode, only one note will be heard at once even if\n   * multiple notes are being played.\n   *\n   * @param mode {string} The mode to use: `\"mono\"` or `\"poly\"`.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setPolyphonicMode(mode, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setPolyphonicMode(mode, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Turns local control on or off. Local control is usually enabled by default. If you disable it,\n   * the instrument will no longer trigger its own sounds. It will only send the MIDI messages to\n   * its out port.\n   *\n   * @param [state=false] {boolean} Whether to activate local control (`true`) or disable it\n   * (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setLocalControl(state, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setLocalControl(state, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sets OMNI mode to `\"on\"` or `\"off\"` for the specified channel(s). MIDI's OMNI mode causes the\n   * instrument to respond to messages from all channels.\n   *\n   * It should be noted that support for OMNI mode is not as common as it used to be.\n   *\n   * @param [state] {boolean} Whether to activate OMNI mode (`true`) or not (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Invalid channel mode message name.\n   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.\n   * @throws {RangeError} Value must be an integer between 0 and 127.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  setOmniMode(state, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setOmniMode(state, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sets a non-registered parameter to the specified value. The NRPN is selected by passing in a\n   * two-position array specifying the values of the two control bytes. The value is specified by\n   * passing in a single integer (most cases) or an array of two integers.\n   *\n   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way\n   * they see fit. For example, according to the Roland GS specification, you can control the\n   * **vibrato rate** using NRPN (1, 8). Therefore, to set the **vibrato rate** value to **123** you\n   * would use:\n   *\n   * ```js\n   * WebMidi.outputs[0].setNonRegisteredParameter([1, 8], 123);\n   * ```\n   *\n   * Obviously, you should select a channel so the message is not sent to all channels. For\n   * instance, to send to channel 1 of the first output port, you would use:\n   *\n   * ```js\n   * WebMidi.outputs[0].setNonRegisteredParameter([1, 8], 123, 1);\n   * ```\n   *\n   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you\n   * would use a 2-position array. For example, for its **ClockBPM** parameter (2, 63), Novation\n   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the\n   * value to send was 10, you could use:\n   *\n   * ```js\n   * WebMidi.outputs[0].setNonRegisteredParameter([2, 63], [0, 10], [1]);\n   * ```\n   *\n   * For further implementation details, refer to the manufacturer\"s documentation.\n   *\n   * @param parameter {number[]} A two-position array specifying the two control bytes (0x63,\n   * 0x62) that identify the non-registered parameter.\n   *\n   * @param [data=[]] {number|number[]} An integer or an array of integers with a length of 1 or 2\n   * specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The control value must be between 0 and 127.\n   * @throws {RangeError} The msb value must be between 0 and 127\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  setNonRegisteredParameter(parameter, data, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].setNonRegisteredParameter(parameter, data, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Increments the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this method:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `\"pitchbendrange\"`\n   *  * Channel Fine Tuning (0x00, 0x01): `\"channelfinetuning\"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `\"channelcoarsetuning\"`\n   *  * Tuning Program (0x00, 0x03): `\"tuningprogram\"`\n   *  * Tuning Bank (0x00, 0x04): `\"tuningbank\"`\n   *  * Modulation Range (0x00, 0x05): `\"modulationrange\"`\n   *  * Azimuth Angle (0x3D, 0x00): `\"azimuthangle\"`\n   *  * Elevation Angle (0x3D, 0x01): `\"elevationangle\"`\n   *  * Gain (0x3D, 0x02): `\"gain\"`\n   *  * Distance Ratio (0x3D, 0x03): `\"distanceratio\"`\n   *  * Maximum Distance (0x3D, 0x04): `\"maximumdistance\"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `\"maximumdistancegain\"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `\"referencedistanceratio\"`\n   *  * Pan Spread Angle (0x3D, 0x07): `\"panspreadangle\"`\n   *  * Roll Angle (0x3D, 0x08): `\"rollangle\"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  incrementRegisteredParameter(parameter, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].incrementRegisteredParameter(parameter, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Decrements the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this method:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `\"pitchbendrange\"`\n   *  * Channel Fine Tuning (0x00, 0x01): `\"channelfinetuning\"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `\"channelcoarsetuning\"`\n   *  * Tuning Program (0x00, 0x03): `\"tuningprogram\"`\n   *  * Tuning Bank (0x00, 0x04): `\"tuningbank\"`\n   *  * Modulation Range (0x00, 0x05): `\"modulationrange\"`\n   *  * Azimuth Angle (0x3D, 0x00): `\"azimuthangle\"`\n   *  * Elevation Angle (0x3D, 0x01): `\"elevationangle\"`\n   *  * Gain (0x3D, 0x02): `\"gain\"`\n   *  * Distance Ratio (0x3D, 0x03): `\"distanceratio\"`\n   *  * Maximum Distance (0x3D, 0x04): `\"maximumdistance\"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `\"maximumdistancegain\"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `\"referencedistanceratio\"`\n   *  * Pan Spread Angle (0x3D, 0x07): `\"panspreadangle\"`\n   *  * Roll Angle (0x3D, 0x08): `\"rollangle\"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter\"s name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @throws TypeError The specified parameter is not available.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  decrementRegisteredParameter(parameter, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].decrementRegisteredParameter(parameter, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **note off** message for the specified notes on the specified channel(s). The first\n   * parameter is the note. It can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *  - A {@link Note} object\n   *\n   *  The execution of the **note off** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using {@link Note} objects, the release velocity defined in the {@link Note} objects has\n   * precedence over the one specified via the method's `options` parameter.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (0-127), a note name (e.g. C3, G#4, F-1, Db7), a\n   * {@link Note} object or an array of the previous types. When using a note name, octave range\n   * must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {boolean} [options.rawValue=false] Controls whether the release velocity is set using\n   * integers between `0` and `127` (`true`) or a decimal number between `0` and `1` (`false`,\n   * default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`\n   * and `1`). If the `rawValue` option is `true`, the value should be specified as an integer\n   * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendNoteOff(note, options= {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].sendNoteOff(note, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * This is an alias to the [sendNoteOff()]{@link Output#sendNoteOff} method.\n   *\n   * @see {@link Output#sendNoteOff}\n   *\n   * @param note\n   * @param options\n   * @returns {Output}\n   */\n  stopNote(note, options) {\n    return this.sendNoteOff(note, options);\n  }\n\n  /**\n   * Plays a note or an array of notes on one or more channels of this output. The first parameter\n   * is the note to play. It can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *  - A {@link Note} object\n   *\n   * The `playNote()` method sends a **note on** MIDI message for all specified notes on all\n   * specified channels. If no channels are specified, it will send to all channels. If a `duration`\n   * is set in the `options` parameter or in the {@link Note} object's\n   * [duration]{@link Note#duration} property, it will also schedule a **note off** message to end\n   * the note after said duration. If no `duration` is set, the note will simply play until a\n   * matching **note off** message is sent with [stopNote()]{@link Output#stopNote} or\n   * [sendNoteOff()]{@link Output#sendNoteOff}.\n   *\n   * The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using {@link Note} objects, the durations and velocities defined in the {@link Note}\n   * objects have precedence over the ones specified via the method's `options` parameter.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (0-127), a note name (e.g. C3, G#4, F-1, Db7), a\n   * {@link Note} object or an array of the previous types. When using a note name, octave range\n   * must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to play the note on. The special value `\"all\"` can\n   * also be used to use all channels (default).\n   *\n   * @param {number} [options.duration=undefined] The number of milliseconds (integer) after which a\n   * **note off** message will be scheduled. If left undefined, only a **note on** message is sent.\n   *\n   * @param {boolean} [options.rawValue=false] Controls whether the attack and release velocities\n   * are set using integers between `0` and `127` (`true`) or a decimal number between `0` and `1`\n   * (`false`, default).\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`\n   * and `1`). If the `rawValue` option is `true`, the value should be specified as an integer\n   * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.\n   * This is only used with the **note off** event triggered when `options.duration` is set.\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @param {number} [options.attack=0.5] The attack velocity to use when playing the note (between\n   * `0` and `1`). If the `rawValue` option is `true`, the value should be specified as an integer\n   * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  playNote(note, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy-compatibility warnings\n      if (options.rawVelocity) {\n        console.warn(\"The 'rawVelocity' option is deprecated. Use 'rawAttack' instead.\");\n      }\n\n      if (options.velocity) {\n        console.warn(\"The 'velocity' option is deprecated. Use 'velocity' instead.\");\n      }\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    Utilities.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].playNote(note, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Sends a **note on** message for the specified notes on the specified channel(s). The first\n   * parameter is the note. It can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `\"C3\"`, `\"G#4\"`, `\"F-1\"`, `\"Db7\"`)\n   *  - A {@link Note} object\n   *\n   *  The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using {@link Note} objects, the attack velocity defined in the {@link Note} objects has\n   * precedence over the one specified via the method's `options` parameter. Also, the `duration` is\n   * ignored. If you want to also send a **note off** message, use the\n   * [playNote()]{@link Output#playNote} method instead.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (0-127), a note name (e.g. C3, G#4, F-1, Db7), a\n   * {@link Note} object or an array of the previous types. When using a note name, octave range\n   * must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]|\"all\"} [options.channels=\"all\"] The MIDI channel number (between `1`\n   * and `16`) or an array of channel numbers to use. The special value `\"all\"` can also be used to\n   * use all channels (default).\n   *\n   * @param {boolean} [options.rawValue=false] Controls whether the attack velocity is set using\n   * integers between `0` and `127` (`true`) or a decimal number between `0` and `1` (`false`,\n   * default).\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `\"+\"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number\n   * (DOMHighResTimeStamp), the operation will be scheduled for that time. If `time` is omitted, or\n   * in the past, the operation will be carried out as soon as possible.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`). If the `rawValue` option is `true`, the value should be specified as an integer\n   * between `0` and `127`. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendNoteOn(note, options = {}, legacy = {}) {\n\n    if (WebMidi.validation) {\n\n      // Legacy compatibility\n      if (Array.isArray(options) || Number.isInteger(options) || options === \"all\") {\n        let channels = options;\n        options = legacy;\n        options.channels = channels;\n      }\n\n    }\n\n    if (options.channels == undefined) options.channels = \"all\";\n\n    WebMidi.sanitizeChannels(options.channels).forEach(ch => {\n      this.channels[ch].sendNoteOn(note, options);\n    });\n\n    return this;\n\n  }\n\n  /**\n   * Name of the MIDI output\n   *\n   * @type {string}\n   * @readonly\n   */\n  get name() {\n    return this._midiOutput.name;\n  }\n\n  /**\n   * ID string of the MIDI output. The ID is host-specific. Do not expect the same ID on different\n   * platforms. For example, Google Chrome and the Jazz-Plugin report completely different IDs for\n   * the same port.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get id() {\n    return this._midiOutput.id;\n  }\n\n  /**\n   * Output port's connection state: `\"pending\"`, `\"open\"` or `\"closed\"`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get connection() {\n    return this._midiOutput.connection;\n  }\n\n  /**\n   * Name of the manufacturer of the device that makes this output port available.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get manufacturer() {\n    return this._midiOutput.manufacturer;\n  }\n\n  /**\n   * State of the output port: `\"connected\"` or `\"disconnected\"`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get state() {\n    return this._midiOutput.state;\n  }\n\n  /**\n   * Type of the output port (`\"output\"`)\n   *\n   * @type {string}\n   * @readonly\n   */\n  get type() {\n    return this._midiOutput.type;\n  }\n\n}\n","import {EventEmitter} from \"../node_modules/djipevents/dist/djipevents.esm.min.js\";\nimport {Input} from \"./Input.js\";\nimport {Output} from \"./Output.js\";\nimport {Utilities} from \"./Utilities.js\";\n\n/*START-NODE.JS*/\n// This block of code is only relevant on Node.js and causes issues with bundlers (such as Webpack)\n// and server-side rendering. This is why it is explicitly being stripped off for the IIFE and ESM\n// distributions.\nglobal[\"performance\"] = require(\"perf_hooks\").performance;\nglobal[\"navigator\"] = require(\"jzz\");\n/*END-NODE.JS*/\n\n/**\n * The `WebMidi` object makes it easier to work with the Web MIDI API. Basically, it simplifies\n * sending outgoing MIDI messages and reacting to incoming MIDI messages.\n *\n * When using the WebMidi.js library, the `WebMidi` class has already been instantiated for you.\n * If you use the **IIFE** version, you should simply use the global object called `WebMidi`. If you\n * use the **CJS** (CommonJS) or **ESM** (ES6 module) version, you get an already-instantiated\n * object. This means there is no need to instantiate a new `WebMidi` object directly.\n *\n * The `WebMidi` object extends the\n * [EventEmitter](https://djipco.github.io/djipevents/EventEmitter.html) class from the\n * [djipevents]{@link https://djipco.github.io/djipevents/index.html} module. This means\n * it also includes methods such as\n * [addListener()](https://djipco.github.io/djipevents/EventEmitter.html#addListener),\n * [removeListener()](https://djipco.github.io/djipevents/EventEmitter.html#removeListener),\n * [hasListener()](https://djipco.github.io/djipevents/EventEmitter.html#hasListener) and several\n * others.\n *\n * @fires WebMidi#connected\n * @fires WebMidi#disabled\n * @fires WebMidi#disconnected\n * @fires WebMidi#enabled\n * @fires WebMidi#midiaccessgranted\n *\n * @extends EventEmitter\n */\nclass WebMidi extends EventEmitter {\n\n  constructor() {\n\n    super();\n\n    /**\n     * Object containing system-wide default values that can be changed to customize how the library\n     * works.\n     *\n     * @type {Object}\n     *\n     * @property {object}  defaults.note - Default values relating to note\n     * @property {number}  defaults.note.attack - A number between 0 and 127 representing the\n     * default attack velocity of notes. Initial value is 64.\n     * @property {number}  defaults.note.release - A number between 0 and 127 representing the\n     * default release velocity of notes. Initial value is 64.\n     * @property {number}  defaults.note.duration - A number representing the default\n     * duration of notes (in seconds). Initial value is Infinity.\n     */\n    this.defaults = {\n      note: {\n        attack: 64,\n        release: 64,\n        duration: Infinity\n      }\n    };\n\n    /**\n     * The `MIDIAccess` instance used to talk to the Web MIDI API. This should not be used directly\n     * unless you know what you are doing.\n     *\n     * @type {?MIDIAccess}\n     * @readonly\n     */\n    this.interface = null;\n\n    /**\n     * Indicates whether argument validation and backwards-compatibility checks are performed\n     * throughout the WebMidi.js library for object methods and property setters.\n     *\n     * This is an advanced setting that should be used carefully. Setting `validation` to `false`\n     * improves performance but should only be done once the project has been thoroughly tested with\n     * validation turned on.\n     *\n     * @type {boolean}\n     */\n    this.validation = true;\n\n    /**\n     * Array of all {@link Input} objects\n     * @type {Input[]}\n     * @private\n     */\n    this._inputs = [];\n\n    /**\n     * Array of all {@link Output} objects\n     * @type {Output[]}\n     * @private\n     */\n    this._outputs = [];\n\n    /**\n     * Array of statechange events to process. These events must be parsed synchronously so they do\n     * not override each other.\n     *\n     * @type {string[]}\n     * @private\n     */\n    this._stateChangeQueue = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this._octaveOffset = 0;\n\n  }\n\n  /**\n   * Checks if the Web MIDI API is available in the current environment and then tries to connect to\n   * the host's MIDI subsystem. This is an asynchronous operation and it causes a security prompt to\n   * be displayed to the user.\n   *\n   * To enable the use of MIDI system exclusive messages, the `sysex` option should be set to\n   * `true`. However, under some environments (e.g. Jazz-Plugin), the `sysex` option is ignored\n   * and system exclusive messages are always enabled. You can check the\n   * [sysexEnabled]{@link WebMidi#sysexEnabled} property to confirm.\n   *\n   * To enable access to software synthesizers available on the host, you would set the `software`\n   * option to `true`. However, this option is only there to future-proof the library as support for\n   * software synths has not yet been implemented in any browser (as of April 2020).\n   *\n   * There are 3 ways to execute code after `WebMidi` has been enabled:\n   *\n   * - Pass a callback function in the `options`\n   * - Listen to the `enabled` event\n   * - Wait for the promise to resolve\n   *\n   * In order, this is what happens towards the end of the enabling process:\n   *\n   * 1. `midiaccessgranted` event is triggered\n   * 2. `connected` events are triggered (for each available input and output)\n   * 3. `enabled` event is triggered when WebMidi.js is ready\n   * 4. specified callback (if any) is executed\n   * 5. promise is resolved\n   *\n   * The promise is fulfilled with an object containing two properties (`inputs` and `outputs`) that\n   * contain arrays of available inputs and outputs, respectively.\n   *\n   * **Important note**: starting with Chrome v77, a page using Web MIDI API must be hosted on a\n   * secure origin (`https://`, `localhost` or `file:///`) and the user will always be prompted to\n   * authorize the operation (no matter if the `sysex` option is `true` or not).\n   *\n   * ##### Example\n   * ```js\n   * // Enabling WebMidi and using the promise\n   * WebMidi.enable().then(ports => {\n   *   console.log(\"WebMidi.js has been enabled!\");\n   *   console.log(\"Inputs: \", ports.inputs);\n   *   console.log(\"Outputs: \", ports.outputs);\n   * })\n   * ```\n   *\n   * @param [options] {Object}\n   *\n   * @param [options.callback] {function} A function to execute once the operation completes. This\n   * function will receive an `Error` object if enabling the Web MIDI API failed.\n   *\n   * @param [options.sysex=false] {boolean} Whether to enable MIDI system exclusive messages or not.\n   *\n   * @param [options.validation=true] {boolean} Whether to enable library-wide validation of method\n   * arguments and setter values. This is an advanced setting that should be used carefully. Setting\n   * `validation` to `false` improves performance but should only be done once the project has been\n   * thoroughly tested with validation turned on.\n   *\n   * @param [options.software=false] {boolean} Whether to request access to software synthesizers on\n   * the host system. This is part of the spec but has not yet been implemented by most browsers as\n   * of April 2020.\n   *\n   * @async\n   *\n   * @returns {Promise<Object>} The promise is fulfilled with an object containing two properties\n   * (`inputs` and `outputs`) that contain arrays of available inputs and outputs, respectively.\n   *\n   * @throws Error The Web MIDI API is not supported in your environment.\n   * @throws Error Jazz-Plugin must be installed to use WebMIDIAPIShim.\n   */\n  async enable(options = {}, legacy = false) {\n\n    this.validation = (options.validation !== false);\n\n    if (this.validation) {\n      // Backwards-compatibility. Previous syntax was: enable(callback, sysex)\n      if (typeof options === \"function\") options = {callback: options, sysex: legacy};\n      if (legacy) options.sysex = true;\n    }\n\n    // If already enabled, trigger callback and resolve promise but to not dispatch events\n    if (this.enabled) {\n      if (typeof options.callback === \"function\") options.callback();\n      return Promise.resolve();\n    }\n\n    // The Jazz-Plugin takes a while to be available (even after the Window's 'load' event has been\n    // fired). Therefore, we wait a little while to give it time to finish loading (initiqted in\n    // constructor).\n    // if (!this.supported) {\n    //\n    //   await new Promise((resolve, reject) => {\n    //\n    //     const start = this.time;\n    //\n    //     const intervalID = setInterval(() => {\n    //\n    //       if (this.supported) {\n    //         clearInterval(intervalID);\n    //         resolve();\n    //       } else {\n    //         if (this.time > start + 1500) {\n    //           clearInterval(intervalID);\n    //           let error = new Error(\"The Web MIDI API is not available in your environment.\");\n    //           if (typeof options.callback === \"function\") options.callback(error);\n    //           reject(error);\n    //         }\n    //       }\n    //\n    //     }, 25);\n    //\n    //   });\n    //\n    // }\n\n    /**\n     * Event emitted when an error occurs trying to enable `WebMidi`\n     *\n     * @event WebMidi#error\n     * @type {Object}\n     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in\n     * milliseconds since the navigation start of the document).\n     * @property {WebMidi} target The object that triggered the event\n     * @property {string} type `error`\n     * @property {*} error Actual error that occurred\n     */\n    const errorEvent = {\n      timestamp: this.time,\n      target: this,\n      type: \"error\",\n      error: undefined\n    };\n\n    /**\n     * Event emitted once the MIDI interface has been successfully created.\n     *\n     * @event WebMidi#midiaccessgranted\n     * @type {Object}\n     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in milliseconds\n     * since the navigation start of the document).\n     * @property {WebMidi} target The object that triggered the event\n     * @property {string} type `midiaccessgranted`\n     */\n    const midiAccessGrantedEvent = {\n      timestamp: this.time,\n      target: this,\n      type: \"midiaccessgranted\"\n    };\n\n    /**\n     * Event emitted once `WebMidi` has been fully enabled\n     *\n     * @event WebMidi#enabled\n     * @type {Object}\n     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in milliseconds\n     * since the navigation start of the document).\n     * @property {WebMidi} target The object that triggered the event\n     * @property {string} type `enabled`\n     */\n    const enabledEvent = {\n      timestamp: this.time,\n      target: this,\n      type: \"enabled\"\n    };\n\n    // Request MIDI access\n    try {\n      this.interface = await navigator.requestMIDIAccess(\n        {sysex: options.sysex, software: options.software}\n      );\n    } catch(err) {\n      errorEvent.error = err;\n      this.emit(\"error\", errorEvent);\n      if (typeof options.callback === \"function\") options.callback(err);\n      return Promise.reject(err);\n    }\n\n    // Now that the Web MIDI API interface has been created, we trigger the 'midiaccessgranted' event.\n    // This allows the developer an occasion to assign listeners on 'connected' events.\n    this.emit(\"midiaccessgranted\", midiAccessGrantedEvent);\n\n    // We setup the statechange listener before creating the ports so that it properly catches the\n    // the ports' `connected` events\n    this.interface.onstatechange = this._onInterfaceStateChange.bind(this);\n\n    // Update inputs and outputs (this is where `Input` and `Output` objects are created).\n    let ports;\n\n    try {\n      ports = await this._updateInputsAndOutputs();\n    } catch (err) {\n      errorEvent.error = err;\n      this.emit(\"error\", errorEvent);\n      if (typeof options.callback === \"function\") options.callback(err);\n      return Promise.reject(err);\n    }\n\n    // If the ports are successfully created, we trigger the 'enabled' event\n    this.emit(\"enabled\", enabledEvent);\n\n    // Execute the callback (if any) and resolve the promise with an object containing inputs and\n    // outputs\n    if (typeof options.callback === \"function\") options.callback();\n\n    return Promise.resolve({\n      inputs: ports[0],\n      outputs: ports[1]\n    });\n\n  }\n\n  /**\n   * Completely disables `WebMidi.js` by unlinking the MIDI subsystem's interface and closing all\n   * {@link Input} and {@link Output} objects that may be available. This also means that listeners\n   * added to {@link Input} objects, {@link Output} objects or to `WebMidi` itself are also\n   * destroyed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   *\n   * @throws Error The Web MIDI API is not supported by your environment.\n   *\n   * @since 2.0.0\n   */\n  async disable() {\n\n    return this._destroyInputsAndOutputs().then(() => {\n\n      if (typeof navigator.close === \"function\") navigator.close();\n\n      if (this.interface) this.interface.onstatechange = undefined;\n      this.interface = null; // also resets enabled, sysexEnabled\n\n      /**\n       * Event emitted once `WebMidi` has been successfully disabled.\n       *\n       * @event WebMidi#disabled\n       * @type {Object}\n       * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in\n       * milliseconds since the navigation start of the document).\n       * @property {WebMidi} target The object that triggered the event\n       * @property {string} type `disabled`\n       */\n      let event = {\n        timestamp: this.time,\n        target: this,\n        type: \"disabled\"\n      };\n\n      // Finally, trigger the 'disabled' event and then remove all listeners.\n      this.emit(\"disabled\", event);\n      this.removeListener();\n\n    });\n\n  };\n\n  /**\n   * Returns the {@link Input} object that matches the specified ID string or `false` if no matching\n   * input is found. As per the Web MIDI API specification, IDs are strings (not integers).\n   *\n   * Please note that IDs change from one host to another. For example, Chrome does not use the same\n   * kind of IDs as Jazz-Plugin.\n   *\n   * @param id {string} The ID string of the input. IDs can be viewed by looking at the\n   * [inputs]{@link WebMidi#inputs} array. Even though they sometimes look like integers, IDs are\n   * strings.\n   *\n   * @returns {Input|false} An {@link Input} object matching the specified ID string. If no matching\n   * input can be found, the method returns `false`.\n   *\n   * @throws Error WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getInputById(id) {\n\n    if (this.validation) {\n      if (!this.enabled) throw new Error(\"WebMidi is not enabled.\");\n      if (!id) return false;\n    }\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      if (this.inputs[i].id === id.toString()) return this.inputs[i];\n    }\n\n    return false;\n\n  };\n\n  /**\n   * Returns the first {@link Input} object whose name **contains** the specified string. Note that\n   * the port names change from one environment to another. For example, Chrome does not report\n   * input names in the same way as the Jazz-Plugin does.\n   *\n   * @param name {string} The non-empty string to look for within the name of MIDI inputs (such as\n   * those visible in the [inputs]{@link WebMidi#inputs} array).\n   *\n   * @returns {Input|false} The {@link Input} that was found or `false` if no input contained the\n   * specified name.\n   *\n   * @throws {Error} WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getInputByName(name) {\n\n    if (this.validation) {\n      if (!this.enabled) throw new Error(\"WebMidi is not enabled.\");\n      if (!name) return false;\n      name = name.toString();\n    }\n\n    for (let i = 0; i < this.inputs.length; i++) {\n      if (~this.inputs[i].name.indexOf(name)) return this.inputs[i];\n    }\n\n    return false;\n\n  };\n\n  /**\n   * Returns the first {@link Output} object whose name **contains** the specified string. Note that\n   * the port names change from one environment to another. For example, Chrome does not report\n   * input names in the same way as the Jazz-Plugin does.\n   *\n   * @param name {string} The non-empty string to look for within the name of MIDI inputs (such as\n   * those visible in the [outputs]{@link WebMidi#outputs} array).\n   *\n   * @returns {Output|false} The {@link Output} that was found or `false` if no output matched the\n   * specified name.\n   *\n   * @throws Error WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getOutputByName(name) {\n\n    if (this.validation) {\n      if (!this.enabled) throw new Error(\"WebMidi is not enabled.\");\n      if (!name) return false;\n      name = name.toString();\n    }\n\n    for (let i = 0; i < this.outputs.length; i++) {\n      if (~this.outputs[i].name.indexOf(name)) return this.outputs[i];\n    }\n\n    return false;\n\n  };\n\n  /**\n   * Returns the {@link Output} object that matches the specified ID string or `false` if no\n   * matching output is found. As per the Web MIDI API specification, IDs are strings (not\n   * integers).\n   *\n   * Please note that IDs change from one host to another. For example, Chrome does not use the same\n   * kind of IDs as Jazz-Plugin.\n   *\n   * @param id {string} The ID string of the port. IDs can be viewed by looking at the\n   * [outputs]{@link WebMidi#outputs} array.\n   *\n   * @returns {Output|false} An {@link Output} object matching the specified ID string. If no\n   * matching output can be found, the method returns `false`.\n   *\n   * @throws Error WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getOutputById(id) {\n\n    if (this.validation) {\n      if (!this.enabled) throw new Error(\"WebMidi is not enabled.\");\n      if (!id) return false;\n    }\n\n    for (let i = 0; i < this.outputs.length; i++) {\n      if (this.outputs[i].id === id.toString()) return this.outputs[i];\n    }\n\n    return false;\n\n  };\n\n  /**\n   * @private\n   * @deprecated since version 3.0. Use Utilities.getNoteNumberByName() instead.\n   */\n  noteNameToNumber(name) {\n    if (this.validation) {\n      console.warn(\n        \"The getNoteNumberByName() method has been moved to the Utilities class in version 3.\"\n      );\n    }\n    return Utilities.getNoteNumberByName(name, {octaveOffset: this.octaveOffset});\n  }\n\n  /**\n   * Returns the octave number for the specified MIDI note number (0-127). By default, the value is\n   * based on middle C (note number 60) being placed on the 4th octave (C4).\n   *\n   * **Note**: since v3.x, this method returns `false` instead of `undefined` when the value cannot\n   * be parsed to a valid octave.\n   *\n   * @param number {number} An integer representing a valid MIDI note number (between 0 and 127).\n   *\n   * @returns {number|false} The octave (as a signed integer) or `false` if the value could not be\n   * parsed to a valid octave.\n   *\n   * @since 2.0.0-rc.6\n   */\n  getOctave(number) {\n\n    if (this.validation) {\n      number = parseInt(number);\n    }\n\n    if (!isNaN(number) && number >= 0 && number <= 127) {\n      return Math.floor(number / 12 - 1) + this.octaveOffset;\n    } else {\n      return false;\n    }\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0. Use Utilities.sanitizeChannels() instead.\n   */\n  sanitizeChannels(channel) {\n\n    if (this.validation) {\n      console.warn(\"The sanitizeChannels() method has been moved to the utilities class.\");\n    }\n\n    return Utilities.sanitizeChannels(channel);\n\n    // let channels;\n    //\n    // if (this.validation) {\n    //\n    //   if (channel === \"all\") { // backwards-compatibility\n    //     channels = [\"all\"];\n    //   } else if (channel === \"none\") { // backwards-compatibility\n    //     return [];\n    //   }\n    //\n    // }\n    //\n    // if (!Array.isArray(channel)) {\n    //   channels = [channel];\n    // } else {\n    //   channels = channel;\n    // }\n    //\n    // // In order to preserve backwards-compatibility, we let this assignment as it is.\n    // if (channels.indexOf(\"all\") > -1) {\n    //   channels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n    // }\n    //\n    // return channels\n    //   .map(function(ch) {\n    //     return parseInt(ch);\n    //   })\n    //   .filter(function(ch) {\n    //     return (ch >= 1 && ch <= 16);\n    //   });\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3.0. Use sanitizeChannels() instead.\n   */\n  toMIDIChannels(channel) {\n\n    if (this.validation) {\n      console.warn(\n        \"The toMIDIChannels() method has been deprecated. Use sanitizeChannels() instead.\"\n      );\n    }\n\n    return Utilities.sanitizeChannels(channel);\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3. Moved to Utilities class.\n   */\n  guessNoteNumber(input) {\n\n    if (this.validation) {\n      console.warn(\n        \"The guessNoteNumber() method has been moved to the Utilities class.\"\n      );\n    }\n\n    return Utilities.guessNoteNumber(input, {octaveOffset: this.octaveOffset});\n\n  }\n\n  /**\n   * @private\n   * @deprecated since version 3. Moved to Utilities class.\n   */\n  getValidNoteArray(notes, options = {}) {\n    if (this.validation) {\n      console.warn(\n        \"The getValidNoteArray() method has been moved to the Utilities class.\"\n      );\n    }\n    return Utilities.getValidNoteArray(notes, options);\n  }\n\n  /**\n   * @private\n   * @deprecated moved to Utilities class.\n   */\n  convertToTimestamp(time) {\n\n    if (this.validation) {\n      console.warn(\n        \"The convertToTimestamp() method has been moved to the utilities class.\"\n      );\n    }\n\n    return Utilities.convertToTimestamp(time);\n\n  }\n\n  /**\n   * @return {Promise<void>}\n   * @private\n   */\n  async _destroyInputsAndOutputs() {\n\n    let promises = [];\n\n    this.inputs.forEach(input => promises.push(input.destroy()));\n    this.outputs.forEach(output => promises.push(output.destroy()));\n\n    return Promise.all(promises).then(() => {\n      this._inputs = [];\n      this._outputs = [];\n    });\n\n  }\n\n  /**\n   * @private\n   */\n  _onInterfaceStateChange(e) {\n\n    this._updateInputsAndOutputs();\n\n    /**\n     * Event emitted when an {@link Input} or {@link Output} becomes available. This event is\n     * typically fired whenever a MIDI device is plugged in. Please note that it may fire several\n     * times if a device possesses multiple inputs and/or outputs (which is often the case).\n     *\n     * @event WebMidi#connected\n     * @type {Object}\n     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred\n     * (in milliseconds since the navigation start of the document).\n     * @property {string} type `connected`\n     * @property {Input|Output} target The {@link Input} or {@link Output} object that triggered the\n     * event.\n     */\n\n    /**\n     * Event emitted when an {@link Input} or {@link Output} becomes unavailable. This event is\n     * typically fired whenever a MIDI device is unplugged. Please note that it may fire several\n     * times if a device possesses multiple inputs and/or outputs (which is often the case).\n     *\n     * @event WebMidi#disconnected\n     * @type {Object}\n     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in milliseconds\n     * since the navigation start of the document).\n     * @property {string} type `disconnected`\n     * @property {Object} target Object with properties describing the {@link Input} or {@Output}\n     * that triggered the event.\n     * @property {string} target.connection `\"closed\"`\n     * @property {string} target.id ID of the input\n     * @property {string} target.manufacturer Manufacturer of the device that provided the input\n     * @property {string} target.name Name of the device that provided the input\n     * @property {string} target.state `disconnected`\n     * @property {string} target.type `input` or `output`\n     */\n    let event = {\n      timestamp: e.timeStamp,\n      type: e.port.state\n    };\n\n    if (this.interface && e.port.state === \"connected\") {\n\n      if (e.port.type === \"output\") {\n        event.port = this.getOutputById(e.port.id); // legacy\n        event.target = event.port;\n      } else if (e.port.type === \"input\") {\n        event.port = this.getInputById(e.port.id); // legacy\n        event.target = event.port;\n      }\n\n    } else {\n\n      // It feels more logical to include a `target` property instead of a `port` property. This is\n      // the terminology used everywhere in the library.\n      event.port = {\n        connection: \"closed\",\n        id: e.port.id,\n        manufacturer: e.port.manufacturer,\n        name: e.port.name,\n        state: e.port.state,\n        type: e.port.type\n      };\n\n      event.target = event.port;\n\n    }\n\n    this.emit(e.port.state, event);\n\n  };\n\n  /**\n   * @private\n   */\n  async _updateInputsAndOutputs() {\n\n    return Promise.all([\n      this._updateInputs(),\n      this._updateOutputs()\n    ]);\n\n  };\n\n  /**\n   * @private\n   */\n  async _updateInputs() {\n\n    // @todo: THIS DOES NOT WORK WHEN THE COMPUTER GOES TO SLEEP BECAUSE STATECHANGE EVENTS ARE\n    //  FIRED ONE AFER THE OTHER. ALSO NEEDS TO BE FIXED IN V2.5\n\n    let promises = [];\n\n    // Check for items to remove from the existing array (because they are no longer being reported\n    // by the MIDI back-end).\n    for (let i = 0; i < this._inputs.length; i++) {\n\n      let remove = true;\n\n      let updated = this.interface.inputs.values();\n\n      for (let input = updated.next(); input && !input.done; input = updated.next()) {\n        if (this._inputs[i]._midiInput === input.value) {\n          remove = false;\n          break;\n        }\n      }\n\n      if (remove) this._inputs.splice(i, 1);\n\n    }\n\n    // Check for items to add in the existing inputs array because they just appeared in the MIDI\n    // back-end inputs list. We must check for the existence of this.interface because it might\n    // have been closed via WebMidi.disable().\n    this.interface && this.interface.inputs.forEach(nInput => {\n\n      let add = true;\n\n      for (let j = 0; j < this._inputs.length; j++) {\n        if (this._inputs[j]._midiInput === nInput) {\n          add = false;\n        }\n      }\n\n      if (add) {\n        let input = new Input(nInput);\n        this._inputs.push(input);\n        promises.push(input.open());\n      }\n\n    });\n\n    return Promise.all(promises);\n\n  };\n\n  /**\n   * @private\n   */\n  async _updateOutputs() {\n\n    let promises = [];\n\n    // Check for items to remove from the existing array (because they are no longer being reported\n    // by the MIDI back-end).\n    for (let i = 0; i < this._outputs.length; i++) {\n\n      let remove = true;\n\n      let updated = this.interface.outputs.values();\n\n      for (let output = updated.next(); output && !output.done; output = updated.next()) {\n        if (this._outputs[i]._midiOutput === output.value) {\n          remove = false;\n          break;\n        }\n      }\n\n      if (remove) {\n        this._outputs[i].close();\n        this._outputs.splice(i, 1);\n      }\n\n    }\n\n    // Check for items to add in the existing inputs array because they just appeared in the MIDI\n    // back-end outputs list. We must check for the existence of this.interface because it might\n    // have been closed via WebMidi.disable().\n    this.interface && this.interface.outputs.forEach(nOutput => {\n\n      let add = true;\n\n      for (let j = 0; j < this._outputs.length; j++) {\n        if (this._outputs[j]._midiOutput === nOutput) {\n          add = false;\n        }\n      }\n\n      if (add) {\n        let output = new Output(nOutput);\n        this._outputs.push(output);\n        promises.push(output.open());\n      }\n\n    });\n\n    return Promise.all(promises);\n\n  };\n\n  // injectPluginMarkup(parent) {\n  //\n  //   // Silently ignore on Node.js\n  //   if (this.isNode) return;\n  //\n  //   // Default to <body> if no parent is specified\n  //   if (!(parent instanceof Element) && !(parent instanceof HTMLDocument)) {\n  //     parent = document.body;\n  //   }\n  //\n  //   // IE10 needs this:\n  //   // <meta http-equiv=\"X-UA-Compatible\" content=\"requiresActiveX=true\"/>\n  //\n  //   // Create markup and add to parent\n  //   const obj = document.createElement(\"object\");\n  //   obj.classid = \"CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90\"; // IE\n  //   if (!obj.isJazz) obj.type = \"audio/x-jazz\";                 // Standards-compliant\n  //   obj.style.visibility = \"hidden\";\n  //   obj.style.width = obj.style.height = \"0px\";\n  //   parent.appendChild(obj);\n  //\n  // }\n\n  /**\n   * Indicates whether access to the host's MIDI subsystem is active or not.\n   *\n   * @readonly\n   * @type {boolean}\n   */\n  get enabled() {\n    return this.interface !== null;\n  }\n\n  /**\n   * An array of all currently available MIDI inputs.\n   *\n   * @readonly\n   * @type {Array}\n   */\n  get inputs() {\n    return this._inputs;\n  }\n\n  /**\n   * Indicates whether the current environment is Node.js or not. If you need to check if we are in\n   * browser, use isBrowser. In certain environments (such as Electron and NW.js) isNode and\n   * isBrowser can both be true at the same time.\n   * @type {boolean}\n   */\n  get isNode() {\n\n    return (Object.prototype.toString.call(\n      typeof process !== \"undefined\" ? process : 0\n    ) === \"[object process]\");\n\n    // Alternative way to try\n    // return typeof process !== \"undefined\" &&\n    //   process.versions != null &&\n    //   process.versions.node != null;\n\n  }\n\n  /**\n   * Indicates whether the current environment is a browser environment or not. If you need to check\n   * if we are in Node.js, use isNode. In certain environments (such as Electron and NW.js) isNode\n   * and isBrowser can both be true at the same time.\n   * @type {boolean}\n   */\n  get isBrowser() {\n    return typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n  }\n\n  /**\n   * An integer to globally offset the octave of both inbound and outbound messages. By default,\n   * middle C (MIDI note number 60) is placed on the 4th octave (C4).\n   *\n   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If\n   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.\n   *\n   * @type {number}\n   *\n   * @since 2.1\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(value) {\n\n    if (this.validation) {\n      value = parseInt(value);\n      if (isNaN(value)) throw new TypeError(\"The 'octaveOffset' property must be an integer.\");\n    }\n\n    this._octaveOffset = value;\n\n  }\n\n  /**\n   * An array of all currently available MIDI outputs.\n   *\n   * @readonly\n   * @type {Array}\n   */\n  get outputs() {\n    return this._outputs;\n  }\n\n  /**\n   * Indicates whether the environment provides support for the Web MIDI API or not.\n   *\n   * **Note**: in environments that do not offer built-in MIDI support, this will report `true` if\n   * the `navigator.requestMIDIAccess` function is available. For example, if you have installed\n   * WebMIDIAPIShim.js but no plugin, this property will be `true` even though actual support might\n   * not be there.\n   *\n   * @readonly\n   * @type {boolean}\n   */\n  get supported() {\n    return (typeof navigator !== \"undefined\" && navigator.requestMIDIAccess);\n  }\n\n  /**\n   * Indicates whether MIDI system exclusive messages have been activated when WebMidi.js was\n   * enabled via the `enable()` method.\n   *\n   * @readonly\n   * @type Boolean\n   */\n  get sysexEnabled() {\n    return !!(this.interface && this.interface.sysexEnabled);\n  }\n\n  /**\n   * The elapsed time, in milliseconds, since the time\n   * [origin](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin).\n   * Said simply, it is the number of milliseconds that passed since the page was loaded. Being a\n   * floating-point number, it has sub-millisecond accuracy. According to the\n   * [documentation](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp), the\n   * time should be accurate to 5 s (microseconds). However, due to various constraints, the\n   * browser might only be accurate to one millisecond.\n   *\n   * @type {DOMHighResTimeStamp}\n   * @readonly\n   */\n  get time() {\n    return performance.now();\n  }\n\n  /**\n   * Enum of all MIDI channel voice messages and their associated numerical value:\n   *\n   * - `noteoff`: 0x8 (8)\n   * - `noteon`: 0x9 (9)\n   * - `keyaftertouch`: 0xA (10)\n   * - `controlchange`: 0xB (11)\n   * - `channelmode`: 0xB (11)\n   * - `nrpn`: 0xB (11)\n   * - `programchange`: 0xC (12)\n   * - `channelaftertouch`: 0xD (13)\n   * - `pitchbend`: 0xE (14)\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   *\n   * @since 3.0.0\n   */\n  get MIDI_CHANNEL_VOICE_MESSAGES() {\n\n    return {\n      noteoff: 0x8,           // 8\n      noteon: 0x9,            // 9\n      keyaftertouch: 0xA,     // 10\n      controlchange: 0xB,     // 11\n      channelmode: 0xB,       // 11\n      nrpn: 0xB,              // 11\n      programchange: 0xC,     // 12\n      channelaftertouch: 0xD, // 13\n      pitchbend: 0xE          // 14\n    };\n\n  }\n\n  /**\n   * Enum of all MIDI channel voice messages and their associated numerical value. Note that it\n   * has been deprecated since v3.0. You should now use\n   * [MIDI_CHANNEL_VOICE_MESSAGES]{@link WebMidi.MIDI_CHANNEL_VOICE_MESSAGES}.\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @deprecated since version 3.0 (will be dropped in version 4.0)\n   *\n   * @since 2.0.0\n   */\n  get MIDI_CHANNEL_MESSAGES() {\n    if (this.validation) {\n      console.warn(\n        \"MIDI_CHANNEL_MESSAGES has been deprecated. Use MIDI_CHANNEL_VOICE_MESSAGES instead.\"\n      );\n    }\n    return this.MIDI_CHANNEL_VOICE_MESSAGES;\n  }\n\n  /**\n   * Enum of all channel mode messages and their associated numerical value:\n   *\n   * - `allsoundoff`: 120\n   * - `resetallcontrollers`: 121\n   * - `localcontrol`: 122\n   * - `allnotesoff`: 123\n   * - `omnimodeoff`: 124\n   * - `omnimodeon`: 125\n   * - `monomodeon`: 126\n   * - `polymodeon`: 127\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   *\n   * @since 2.0.0\n   */\n  get MIDI_CHANNEL_MODE_MESSAGES() {\n\n    return {\n      allsoundoff: 120,\n      resetallcontrollers: 121,\n      localcontrol: 122,\n      allnotesoff: 123,\n      omnimodeoff: 124,\n      omnimodeon: 125,\n      monomodeon: 126,\n      polymodeon: 127\n    };\n\n  }\n\n  /**\n   * Enum of all control change messages and their associated numerical value:\n   *\n   * - `bankselectcoarse`: 0\n   * - `modulationwheelcoarse`: 1\n   * - `breathcontrollercoarse`: 2\n   * - `footcontrollercoarse`: 4\n   * - `portamentotimecoarse`: 5\n   * - `dataentrycoarse`: 6\n   * - `volumecoarse`: 7\n   * - `balancecoarse`: 8\n   * - `pancoarse`: 10\n   * - `expressioncoarse`: 11\n   * - `effectcontrol1coarse`: 12\n   * - `effectcontrol2coarse`: 13\n   * - `generalpurposeslider1`: 16\n   * - `generalpurposeslider2`: 17\n   * - `generalpurposeslider3`: 18\n   * - `generalpurposeslider4`: 19\n   * - `bankselectfine`: 32\n   * - `modulationwheelfine`: 33\n   * - `breathcontrollerfine`: 34\n   * - `footcontrollerfine`: 36\n   * - `portamentotimefine`: 37\n   * - `dataentryfine`: 38\n   * - `volumefine`: 39\n   * - `balancefine`: 40\n   * - `panfine`: 42\n   * - `expressionfine`: 43\n   * - `effectcontrol1fine`: 44\n   * - `effectcontrol2fine`: 45\n   * - `holdpedal`: 64\n   * - `portamento`: 65\n   * - `sustenutopedal`: 66\n   * - `softpedal`: 67\n   * - `legatopedal`: 68\n   * - `hold2pedal`: 69\n   * - `soundvariation`: 70\n   * - `resonance`: 71\n   * - `soundreleasetime`: 72\n   * - `soundattacktime`: 73\n   * - `brightness`: 74\n   * - `soundcontrol6`: 75\n   * - `soundcontrol7`: 76\n   * - `soundcontrol8`:`77\n   * - `soundcontrol9`: 78\n   * - `soundcontrol10`: 79\n   * - `generalpurposebutton1`: 80\n   * - `generalpurposebutton2`: 81\n   * - `generalpurposebutton3`: 82\n   * - `generalpurposebutton4`: 83\n   * - `reverblevel`: 91\n   * - `tremololevel`: 92\n   * - `choruslevel`: 93\n   * - `celestelevel`: 94\n   * - `phaserlevel`: 95\n   * - `databuttonincrement`: 96\n   * - `databuttondecrement`: 97\n   * - `nonregisteredparametercoarse`: 98\n   * - `nonregisteredparameterfine`: 99\n   * - `registeredparametercoarse`: 100\n   * - `registeredparameterfine`: 101\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   *\n   * @since 2.0.0\n   */\n  get MIDI_CONTROL_CHANGE_MESSAGES() {\n\n    return {\n      bankselectcoarse: 0,\n      modulationwheelcoarse: 1,\n      breathcontrollercoarse: 2,\n      footcontrollercoarse: 4,\n      portamentotimecoarse: 5,\n      dataentrycoarse: 6,\n      volumecoarse: 7,\n      balancecoarse: 8,\n      pancoarse: 10,\n      expressioncoarse: 11,\n      effectcontrol1coarse: 12,\n      effectcontrol2coarse: 13,\n      generalpurposeslider1: 16,\n      generalpurposeslider2: 17,\n      generalpurposeslider3: 18,\n      generalpurposeslider4: 19,\n      bankselectfine: 32,\n      modulationwheelfine: 33,\n      breathcontrollerfine: 34,\n      footcontrollerfine: 36,\n      portamentotimefine: 37,\n      dataentryfine: 38,\n      volumefine: 39,\n      balancefine: 40,\n      panfine: 42,\n      expressionfine: 43,\n      effectcontrol1fine: 44,\n      effectcontrol2fine: 45,\n      holdpedal: 64,\n      portamento: 65,\n      sustenutopedal: 66,\n      softpedal: 67,\n      legatopedal: 68,\n      hold2pedal: 69,\n      soundvariation: 70,\n      resonance: 71,\n      soundreleasetime: 72,\n      soundattacktime: 73,\n      brightness: 74,\n      soundcontrol6: 75,\n      soundcontrol7: 76,\n      soundcontrol8: 77,\n      soundcontrol9: 78,\n      soundcontrol10: 79,\n      generalpurposebutton1: 80,\n      generalpurposebutton2: 81,\n      generalpurposebutton3: 82,\n      generalpurposebutton4: 83,\n      reverblevel: 91,\n      tremololevel: 92,\n      choruslevel: 93,\n      celestelevel: 94,\n      phaserlevel: 95,\n      databuttonincrement: 96,\n      databuttondecrement: 97,\n      nonregisteredparametercoarse: 98,\n      nonregisteredparameterfine: 99,\n      registeredparametercoarse: 100,\n      registeredparameterfine: 101\n    };\n\n  }\n\n  /**\n   * Array of valid events triggered at the interface level.\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  get MIDI_INTERFACE_EVENTS() {\n    return [\"connected\", \"disconnected\"];\n  }\n\n  /**\n   * Enum of all control change messages that are used to create NRPN messages and their associated\n   * numerical value:\n   *\n   * - `entrymsb`: 6\n   * - `entrylsb`: 38\n   * - `increment`: 96\n   * - `decrement`: 97\n   * - `paramlsb`: 98\n   * - `parammsb`: 99\n   * - `nullactiveparameter`: 127\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   *\n   * @since 2.0.0\n   */\n  get MIDI_NRPN_MESSAGES() {\n\n    return {\n      entrymsb: 6,\n      entrylsb: 38,\n      increment: 96,\n      decrement: 97,\n      paramlsb: 98,\n      parammsb: 99,\n      nullactiveparameter: 127\n    };\n\n  }\n\n  /**\n   * Enum of all registered parameters and their associated pair of numerical values. MIDI\n   * registered parameters extend the original list of control change messages. Currently, there are\n   * only a limited number of them:\n   *\n   * - `pitchbendrange`: [0x00, 0x00]\n   * - `channelfinetuning`: [0x00, 0x01]\n   * - `channelcoarsetuning`: [0x00, 0x02]\n   * - `tuningprogram`: [0x00, 0x03]\n   * - `tuningbank`: [0x00, 0x04]\n   * - `modulationrange`: [0x00, 0x05]\n   * - `azimuthangle`: [0x3D, 0x00]\n   * - `elevationangle`: [0x3D, 0x01]\n   * - `gain`: [0x3D, 0x02]\n   * - `distanceratio`: [0x3D, 0x03]\n   * - `maximumdistance`: [0x3D, 0x04]\n   * - `maximumdistancegain`: [0x3D, 0x05]\n   * - `referencedistanceratio`: [0x3D, 0x06]\n   * - `panspreadangle`: [0x3D, 0x07]\n   * - `rollangle`: [0x3D, 0x08]\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   *\n   * @since 2.0.0\n   */\n  get MIDI_REGISTERED_PARAMETER() {\n\n    return {\n      pitchbendrange: [0x00, 0x00],\n      channelfinetuning: [0x00, 0x01],\n      channelcoarsetuning: [0x00, 0x02],\n      tuningprogram: [0x00, 0x03],\n      tuningbank: [0x00, 0x04],\n      modulationrange: [0x00, 0x05],\n      azimuthangle: [0x3D, 0x00],\n      elevationangle: [0x3D, 0x01],\n      gain: [0x3D, 0x02],\n      distanceratio: [0x3D, 0x03],\n      maximumdistance: [0x3D, 0x04],\n      maximumdistancegain: [0x3D, 0x05],\n      referencedistanceratio: [0x3D, 0x06],\n      panspreadangle: [0x3D, 0x07],\n      rollangle: [0x3D, 0x08]\n    };\n\n  }\n\n  /**\n   * Enum of all valid MIDI system messages and matching numerical values. WebMidi.js also uses\n   * two custom messages.\n   *\n   * **System common messages**\n   * - `sysex`: 0xF0 (240)\n   * - `timecode`: 0xF1 (241)\n   * - `songposition`: 0xF2 (242)\n   * - `songselect`: 0xF3 (243)\n   * - `tunerequest`: 0xF6 (246)\n   * - `sysexend`: 0xF7 (247)\n   *\n   * The `sysexend` message is never actually received. It simply ends a sysex stream.\n   *\n   * **System real-time messages**\n   *\n   * - `clock`: 0xF8 (248)\n   * - `start`: 0xFA (250)\n   * - `continue`: 0xFB (251)\n   * - `stop`: 0xFC (252)\n   * - `activesensing`: 0xFE (254)\n   * - `reset`: 0xFF (255)\n   *\n   * Values 249 and 253 are actually relayed by the Web MIDI API but they do not serve a specific\n   * purpose. The\n   * [MIDI 1.0 spec](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)\n   * simply states that they are undefined/reserved.\n   *\n   * **Custom WebMidi.js messages**\n   *\n   * - `midimessage`: 0\n   * - `unknownsystemmessage`: -1\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   *\n   * @since 2.0.0\n   */\n  get MIDI_SYSTEM_MESSAGES() {\n\n    return {\n\n      // System common messages\n      sysex: 0xF0,            // 240\n      timecode: 0xF1,         // 241\n      songposition: 0xF2,     // 242\n      songselect: 0xF3,       // 243\n      tunerequest: 0xF6,      // 246\n      tuningrequest: 0xF6,    // for backwards-compatibility (deprecated in version 3.0)\n      sysexend: 0xF7,         // 247 (never actually received - simply ends a sysex)\n\n      // System real-time messages\n      clock: 0xF8,            // 248\n      start: 0xFA,            // 250\n      continue: 0xFB,         // 251\n      stop: 0xFC,             // 252\n      activesensing: 0xFE,    // 254\n      reset: 0xFF,            // 255\n\n      // Custom WebMidi.js messages\n      midimessage: 0,\n      unknownsystemmessage: -1\n\n    };\n\n  }\n\n  /**\n   * Array of standard note names\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  get NOTES() {\n    return [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n  }\n\n}\n\n// Export singleton instance of WebMidi class. The 'constructor' is nulled so that it cannot be used\n// to instantiate a new WebMidi object or extend it. However, it is not freezed so it remains\n// extensible (properties can be added at will).\nconst wm = new WebMidi();\nwm.constructor = null;\nexport {wm as WebMidi};\n\nexport {Note} from \"./Note.js\";\nexport {Utilities} from \"./Utilities.js\";\n"],"names":["EventEmitter","[object Object]","eventsSuspended","eventMap","this","event","callback","options","length","String","ANY_EVENT","TypeError","listener","Listener","prepend","unshift","push","remaining","addListener","Symbol","for","Object","entries","some","value","filter","undefined","keys","getListeners","forEach","suspended","args","results","listeners","concat","params","Array","isArray","arguments","apply","context","count","remove","duration","parseInt","isNaN","Infinity","Promise","resolve","reject","timeout","clearTimeout","setTimeout","target","ReferenceError","assign","removeListener","utils","getNoteNumberByName","name","octaveOffset","RangeError","fragments","getNoteFragments","result","octave","C","D","E","F","G","A","B","letter","accidental","startsWith","matches","match","toUpperCase","toLowerCase","sanitizeChannels","channel","channels","validation","indexOf","map","ch","convertToTimestamp","time","parsed","parseFloat","substring","guessNoteNumber","input","output","Number","isInteger","getNoteObject","Note","number","getValidNoteArray","notes","note","getNoteNameByNumber","Math","floor","WebMidi","NOTES","toString","constructor","defaults","attack","release","Utilities","_name","Error","_duration","_attack","_release","InputChannel","_forwardTo","_octaveOffset","destroy","_parseEvent","e","dataBytes","data","MIDI_SYSTEM_MESSAGES","sysex","slice","midiMessageEvent","from","rawData","statusByte","timestamp","timeStamp","type","emit","_parseEventForStandardMessages","getStructuredMidiMessage","command","data1","data2","MIDI_CHANNEL_VOICE_MESSAGES","noteoff","noteon","rawRelease","rawAttack","keyaftertouch","rawValue","controlchange","controller","getCcNameByNumber","channelmode","getChannelModeByNumber","_parseChannelModeMessage","programchange","channelaftertouch","pitchbend","cm","MIDI_CHANNEL_MODE_MESSAGES","hasOwnProperty","cc","MIDI_CONTROL_CHANGE_MESSAGES","Input","midiInput","_midiInput","i","onstatechange","_onStateChange","bind","onmidimessage","_onMidiMessage","close","port","connection","state","id","manufacturer","console","warn","timecode","songposition","songselect","song","tunerequest","clock","start","continue","stop","activesensing","reset","open","err","super","addOneTimeListener","on","hasListener","every","OutputChannel","send","message","setKeyAftertouch","pressure","useRawValue","round","n","sendControlChange","_selectNonRegisteredParameter","parameter","_deselectRegisteredParameter","_deselectNonRegisteredParameter","_selectRegisteredParameter","_setCurrentParameter","decrementRegisteredParameter","MIDI_REGISTERED_PARAMETER","valid","getOwnPropertyNames","p","incrementRegisteredParameter","playNote","sendNoteOn","isFinite","trim","NaN","noteOffOptions","sendNoteOff","rawVelocity","velocity","nVelocity","o","stopNote","sendChannelMode","setOmniMode","setChannelAftertouch","setMasterTuning","coarse","fine","msb","lsb","setRegisteredParameter","setModulationRange","semitones","cents","setNonRegisteredParameter","nrpn","setPitchBend","nLevel","setPitchBendRange","setProgram","program","rpn","setTuningBank","setTuningProgram","setLocalControl","turnNotesOff","turnSoundOff","resetAllControllers","setPolyphonicMode","mode","Output","midiOutput","_midiOutput","legacy","Uint8Array","sendSysex","sysexend","clear","sendTimecodeQuarterFrame","setSongPosition","sendSongPosition","setSong","sendSongSelect","sendTuneRequest","sendClock","sendStart","sendContinue","sendStop","sendActiveSensing","sendReset","sendTuningRequest","sendKeyAftertouch","sendChannelAftertouch","sendPitchBend","bend","sendProgramChange","global","require","performance","wm","interface","_inputs","_outputs","_stateChangeQueue","enabled","errorEvent","error","midiAccessGrantedEvent","enabledEvent","navigator","requestMIDIAccess","software","ports","_onInterfaceStateChange","_updateInputsAndOutputs","inputs","outputs","_destroyInputsAndOutputs","then","getInputById","getInputByName","getOutputByName","getOutputById","noteNameToNumber","getOctave","toMIDIChannels","promises","all","_updateInputs","_updateOutputs","updated","values","next","done","splice","nInput","add","j","nOutput","prototype","call","process","window","document","sysexEnabled","now","allsoundoff","resetallcontrollers","localcontrol","allnotesoff","omnimodeoff","omnimodeon","monomodeon","polymodeon","bankselectcoarse","modulationwheelcoarse","breathcontrollercoarse","footcontrollercoarse","portamentotimecoarse","dataentrycoarse","volumecoarse","balancecoarse","pancoarse","expressioncoarse","effectcontrol1coarse","effectcontrol2coarse","generalpurposeslider1","generalpurposeslider2","generalpurposeslider3","generalpurposeslider4","bankselectfine","modulationwheelfine","breathcontrollerfine","footcontrollerfine","portamentotimefine","dataentryfine","volumefine","balancefine","panfine","expressionfine","effectcontrol1fine","effectcontrol2fine","holdpedal","portamento","sustenutopedal","softpedal","legatopedal","hold2pedal","soundvariation","resonance","soundreleasetime","soundattacktime","brightness","soundcontrol6","soundcontrol7","soundcontrol8","soundcontrol9","soundcontrol10","generalpurposebutton1","generalpurposebutton2","generalpurposebutton3","generalpurposebutton4","reverblevel","tremololevel","choruslevel","celestelevel","phaserlevel","databuttonincrement","databuttondecrement","nonregisteredparametercoarse","nonregisteredparameterfine","registeredparametercoarse","registeredparameterfine","entrymsb","entrylsb","increment","decrement","paramlsb","parammsb","nullactiveparameter","pitchbendrange","channelfinetuning","channelcoarsetuning","tuningprogram","tuningbank","modulationrange","azimuthangle","elevationangle","gain","distanceratio","maximumdistance","maximumdistancegain","referencedistanceratio","panspreadangle","rollangle","tuningrequest","midimessage","unknownsystemmessage"],"mappings":"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"}