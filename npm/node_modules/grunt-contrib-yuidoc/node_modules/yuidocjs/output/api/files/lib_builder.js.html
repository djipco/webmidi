<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/builder.js - yuidoc-root</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="yuidoc-root" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.9.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/CLI.html">CLI</a></li>
                                <li><a href="../classes/DocBuilder.html">DocBuilder</a></li>
                                <li><a href="../classes/DocParser.html">DocParser</a></li>
                                <li><a href="../classes/DocView.html">DocView</a></li>
                                <li><a href="../classes/Files.html">Files</a></li>
                                <li><a href="../classes/Help.html">Help</a></li>
                                <li><a href="../classes/Main.html">Main</a></li>
                                <li><a href="../classes/Options.html">Options</a></li>
                                <li><a href="../classes/Server.html">Server</a></li>
                                <li><a href="../classes/Utils.html">Utils</a></li>
                                <li><a href="../classes/YUIDoc.html">YUIDoc</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/yuidoc.html">yuidoc</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/builder.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Copyright (c) 2011, Yahoo! Inc. All rights reserved.
 * Code licensed under the BSD License:
 * https://github.com/yui/yuidoc/blob/master/LICENSE
 */
&#x27;use strict&#x27;;

var MarkdownIt = require(&#x27;markdown-it&#x27;);
var fs = require(&#x27;graceful-fs&#x27;);
var mdn = require(&#x27;mdn-links&#x27;);
var noop = function () {};
var path = require(&#x27;path&#x27;);
var TEMPLATE;

/**
* Takes the &#x60;JSON&#x60; data from the &#x60;DocParser&#x60; class, creates and parses markdown and handlebars
based templates to generate static HTML content
* @class DocBuilder
* @module yuidoc
*/

YUI.add(&#x27;doc-builder&#x27;, function (Y) {
    var defaultMarkdownOption = {
        html: true,
        linkify: true
    };

    var fixType = Y.Lang.fixType,
        print = function (items) {
            var out = &#x27;&lt;ul&gt;&#x27;;

            Y.each(items, function (i, k) {
                out += &#x27;&lt;li&gt;&#x27;;
                if (Y.Lang.isObject(i)) {
                    if (!i.path) {
                        out += k + &#x27;/&#x27; + print(i);
                    } else {
                        out += &#x27;&lt;a href=&quot;../files/&#x27; + i.name + &#x27;.html&quot;&gt;&#x27; + k + &#x27;&lt;/a&gt;&#x27;;
                    }
                }
                out += &#x27;&lt;/li&gt;&#x27;;
            });

            out += &#x27;&lt;/ul&gt;&#x27;;
            return out;
        };

    Y.Handlebars.registerHelper(&#x27;buildFileTree&#x27;, function (items) {
        return print(items);
    });

    var DEFAULT_THEME = path.join(__dirname, &#x27;../&#x27;, &#x27;themes&#x27;, &#x27;default&#x27;),
        themeDir = DEFAULT_THEME;

    Y.DocBuilder = function (options, data) {
        this.options = options;
        if (options.helpers) {
            this._addHelpers(options.helpers);
        }
        if (options.themedir) {
            themeDir = options.themedir;
        }
        this.md = new MarkdownIt(Y.merge(defaultMarkdownOption, options.markdown));
        this.data = data;
        Y.log(&#x27;Building..&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
        this.files = 0;
        var self = this;

        Y.Handlebars.registerHelper(&#x27;crossLink&#x27;, function (item, helperOptions) {
            var str = &#x27;&#x27;;
            if (!item) {
                item = &#x27;&#x27;;
            }
            //console.log(&#x27;CrossLink:&#x27;, item);
            if (item.indexOf(&#x27;|&#x27;) &gt; 0) {
                var parts = item.split(&#x27;|&#x27;),
                    p = [];
                Y.each(parts, function (i) {
                    p.push(self._parseCrossLink.call(self, i));
                });
                str = p.join(&#x27; | &#x27;);
            } else {
                str = self._parseCrossLink.call(self, item, false, helperOptions.fn(this));
            }
            return str;
        });

        Y.Handlebars.registerHelper(&#x27;crossLinkModule&#x27;, function (item, helperOptions) {
            var str = item;
            if (self.data.modules[item]) {
                var content = helperOptions.fn(this);
                if (content === &#x27;&#x27;) {
                    content = item;
                }
                str = &#x27;&lt;a href=&quot;../modules/&#x27; + item.replace(/\//g, &#x27;_&#x27;) +
                    &#x27;.html&quot;&gt;&#x27; + content + &#x27;&lt;/a&gt;&#x27;;
            }
            return str;
        });

        Y.Handlebars.registerHelper(&#x27;crossLinkRaw&#x27;, function (item) {
            var str = &#x27;&#x27;;
            if (!item) {
                item = &#x27;&#x27;;
            }
            if (item.indexOf(&#x27;|&#x27;) &gt; 0) {
                var parts = item.split(&#x27;|&#x27;),
                    p = [];
                Y.each(parts, function (i) {
                    p.push(self._parseCrossLink.call(self, i, true));
                });
                str = p.join(&#x27; | &#x27;);
            } else {
                str = self._parseCrossLink.call(self, item, true);
            }
            return str;
        });

        this.cacheTemplates = true;
        if (options.cacheTemplates === false) {
            this.cacheTemplates = false;
        }
    };

    Y.DocBuilder.prototype = {
        /**
         * Register a &#x60;Y.Handlebars&#x60; helper method
         * @method _addHelpers
         * @param {Object} helpers Object containing a hash of names and functions
         */
        _addHelpers: function (helpers) {
            Y.log(&#x27;Importing helpers: &#x27; + helpers, &#x27;info&#x27;, &#x27;builder&#x27;);
            helpers.forEach(function (imp) {
                if (!Y.Files.exists(imp) || Y.Files.exists(path.join(process.cwd(), imp))) {
                    imp = path.join(process.cwd(), imp);
                }
                var h = require(imp);
                Object.keys(h).forEach(function (name) {
                    Y.Handlebars.registerHelper(name, h[name]);
                });
            });
        },

        /**
         * Wrapper around the Markdown parser so it can be normalized or even side stepped
         * @method markdown
         * @private
         * @param {String} data The Markdown string to parse
         * @return {HTML} The rendered HTML
         */
        markdown: function (data) {
            var html = this.md.render(data);
            //Only reprocess if helpers were asked for
            if (this.options.helpers || (html.indexOf(&#x27;{{#crossLink&#x27;) &gt; -1)) {
                try {
                    // markdown-it auto-escapes quotation marks (and unfortunately
                    // does not expose the escaping function)
                    html = html.replace(/&amp;quot;/g, &#x27;&quot;&#x27;);
                    html = (Y.Handlebars.compile(html))({});
                } catch (hError) {
                    //Remove all the extra escapes
                    html = html.replace(/\\{/g, &#x27;{&#x27;).replace(/\\}/g, &#x27;}&#x27;);
                    Y.log(&#x27;Failed to parse Handlebars, probably an unknown helper, skipping..&#x27;, &#x27;warn&#x27;, &#x27;builder&#x27;);
                }
            }
            return html;
        },

        /**
         * Parse the item to be cross linked and return an HREF linked to the item
         * @method _parseCrossLink
         * @private
         * @param {String} item The item to crossLink
         * @param {Boolean} [raw=false] Do not wrap it in HTML
         * @param {String} [content] crossLink helper content
         */
        _parseCrossLink: function (item, raw, content) {
            var self = this;
            var parts,
                base = &#x27;../&#x27;,
                baseItem,
                newWin = false,
                group = /&amp;lt;.*(?=&amp;gt;$)/.test(item) ? &#x27;elements&#x27; : &#x27;classes&#x27;,
                className = &#x27;crosslink&#x27;;

            if (group === &#x27;classes&#x27;) {
                item = fixType(item);
            }

            item = baseItem = Y.Lang.trim(item.replace(&#x27;{&#x27;, &#x27;&#x27;).replace(&#x27;}&#x27;, &#x27;&#x27;));
            //Remove Cruft
            item = item.replace(&#x27;*&#x27;, &#x27;&#x27;).replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;).replace(&#x27;&amp;lt;&#x27;, &#x27;&#x27;).replace(&#x27;&amp;gt;&#x27;, &#x27;&#x27;);

            var link = false,
                href;

            if (self.data[group][item]) {
                link = true;
            } else {
                if (self.data[group][item.replace(&#x27;.&#x27;, &#x27;&#x27;)]) {
                    link = true;
                    item = item.replace(&#x27;.&#x27;, &#x27;&#x27;);
                }
            }
            if (self.options.externalData) {
                if (self.data[group][item]) {
                    if (self.data[group][item].external) {
                        href = self.data[group][item].path;
                        base = self.options.externalData.base;
                        className += &#x27; external&#x27;;
                        newWin = true;
                        link = true;
                    }
                }
            }

            if (group === &#x27;elements&#x27; &amp;&amp; item.indexOf(&#x27; &#x27;) &gt; -1) {
                // Fragment link for an attribute is required
                parts = item.split(&#x27; &#x27;);
                var el = parts[0],
                    attr = parts[1];

                if (el &amp;&amp; attr) {
                    if (self.data.elements[el]) {
                        self.data.elements[el].attributes.some(function (i) {
                            if (i.name === attr) {
                                link = true;
                                baseItem = attr;
                                href = Y.webpath(base, &#x27;elements&#x27;, el + &#x27;.html#&#x27; + attr);
                            }
                        });
                    }
                }
            } else if (item.indexOf(&#x27;/&#x27;) &gt; -1) {
                //We have a class + method to parse
                parts = item.split(&#x27;/&#x27;);
                var cls = parts[0],
                    method = parts[1],
                    type = &#x27;method&#x27;;

                if (method.indexOf(&#x27;:&#x27;) &gt; -1) {
                    parts = method.split(&#x27;:&#x27;);
                    method = parts[0];
                    type = parts[1];
                    if (type.indexOf(&#x27;attr&#x27;) === 0) {
                        type = &#x27;attribute&#x27;;
                    }
                }

                if (cls &amp;&amp; method) {
                    if (self.data.classes[cls]) {
                        self.data.classitems.forEach(function (i) {
                            if (i.itemtype === type &amp;&amp; i.name === method &amp;&amp; i.class === cls) {
                                link = true;
                                baseItem = method;
                                var t = type;
                                if (t === &#x27;attribute&#x27;) {
                                    t = &#x27;attr&#x27;;
                                }
                                href = Y.webpath(base, &#x27;classes&#x27;, cls + &#x27;.html#&#x27; + t + &#x27;_&#x27; + method);
                            }
                        });
                    }
                }

            }

            if (item === &#x27;Object&#x27; || item === &#x27;Array&#x27;) {
                link = false;
            }
            if (!href) {
                href = Y.webpath(base, group, item + &#x27;.html&#x27;);
                if (base.match(/^https?:\/\//)) {
                    href = base + Y.webpath(group, item + &#x27;.html&#x27;);
                }
            }
            if (!link &amp;&amp; self.options.linkNatives) {
                href = mdn.getLink.apply(mdn, item.split(&#x27;/&#x27;));
                if (href) {
                    className += &#x27; external&#x27;;
                    newWin = true;
                    link = true;
                }
            }
            if (link) {
                if (content !== undefined) {
                    content = content.trim();
                }
                if (!content) {
                    content = baseItem;
                }
                item = &#x27;&lt;a href=&quot;&#x27; + href + &#x27;&quot; class=&quot;&#x27; + className + &#x27;&quot;&#x27; + ((newWin) ? &#x27; target=&quot;_blank&quot;&#x27; : &#x27;&#x27;) + &#x27;&gt;&#x27; + content + &#x27;&lt;/a&gt;&#x27;;
            }
            return (raw) ? href : item;
        },

        /**
         * Mixes the various external data soures together into the local data, augmenting
         * it with flags.
         * @method _mixExternal
         * @private
         */
        _mixExternal: function () {
            var self = this;
            Y.log(&#x27;External data received, mixing&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
            self.options.externalData.forEach(function (exData) {

                [&#x27;files&#x27;, &#x27;elements&#x27;, &#x27;classes&#x27;, &#x27;modules&#x27;].forEach(function (k) {
                    Y.each(exData[k], function (item, key) {
                        item.external = true;
                        var file = item.name;
                        if (!item.file) {
                            file = self.filterFileName(item.name);
                        }

                        if (item.type) {
                            item.type = fixType(item.type);
                        }

                        item.path = exData.base + path.join(k, file + &#x27;.html&#x27;);

                        self.data[k][key] = item;
                    });
                });
                Y.each(exData.classitems, function (item) {
                    item.external = true;
                    item.path = exData.base + path.join(&#x27;files&#x27;, self.filterFileName(item.file) + &#x27;.html&#x27;);
                    if (item.type) {
                        item.type = fixType(item.type);
                    }
                    if (item.params) {
                        item.params.forEach(function (p) {
                            if (p.type) {
                                p.type = fixType(p.type);
                            }
                        });
                    }
                    if (item.return) {
                        item.return.type = fixType(item.return.type);
                    }
                    self.data.classitems.push(item);
                });
            });
        },
        /**
         * Fetches the remote data and fires the callback when it&#x27;s all complete
         * @method mixExternal
         * @param {Callback} cb The callback to execute when complete
         * @async
         */
        mixExternal: function (cb) {
            var self = this,
                info = self.options.external;

            if (!info) {
                cb();
                return;
            }
            if (!info.merge) {
                info.merge = &#x27;mix&#x27;;
            }
            if (!info.data) {
                Y.log(&#x27;External config found but no data path defined, skipping import.&#x27;, &#x27;warn&#x27;, &#x27;builder&#x27;);
                cb();
                return;
            }
            if (!Y.Lang.isArray(info.data)) {
                info.data = [info.data];
            }
            Y.log(&#x27;Importing external documentation data.&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);

            var stack = new Y.Parallel();
            info.data.forEach(function (i) {
                var base;
                if (typeof i === &#x27;object&#x27;) {
                    base = i.base;
                    i = i.json;
                }
                if (i.match(/^https?:\/\//)) {
                    if (!base) {
                        base = i.replace(&#x27;data.json&#x27;, &#x27;&#x27;);
                    }
                    Y.use(&#x27;io-base&#x27;, stack.add(function () {
                        Y.log(&#x27;Fetching: &#x27; + i, &#x27;info&#x27;, &#x27;builder&#x27;);
                        Y.io(i, {
                            on: {
                                complete: stack.add(function (id, e) {
                                    Y.log(&#x27;Received: &#x27; + i, &#x27;info&#x27;, &#x27;builder&#x27;);
                                    var parsedData = JSON.parse(e.responseText);
                                    parsedData.base = base;
                                    //self.options.externalData = Y.mix(self.options.externalData || {}, data);
                                    if (!self.options.externalData) {
                                        self.options.externalData = [];
                                    }
                                    self.options.externalData.push(parsedData);
                                })
                            }
                        });
                    }));
                } else {
                    if (!base) {
                        base = path.dirname(path.resolve(i));
                    }
                    var data = Y.Files.getJSON(i);
                    data.base = base;
                    //self.options.externalData = Y.mix(self.options.externalData || {}, data);
                    if (!self.options.externalData) {
                        self.options.externalData = [];
                    }
                    self.options.externalData.push(data);
                }
            });

            stack.done(function () {
                Y.log(&#x27;Finished fetching remote data&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
                self._mixExternal();
                cb();
            });
        },
        /**
         * File counter
         * @property files
         * @type Number
         */
        files: null,
        /**
         * Holder for project meta data
         * @property _meta
         * @type Object
         * @private
         */
        _meta: null,
        /**
         * Prep the meta data to be fed to Selleck
         * @method getProjectMeta
         * @return {Object} The project metadata
         */
        getProjectMeta: function () {
            var obj = {
                meta: {
                    yuiSeedUrl: &#x27;http://yui.yahooapis.com/3.5.0/build/yui/yui-min.js&#x27;,
                    yuiGridsUrl: &#x27;http://yui.yahooapis.com/3.5.0/build/cssgrids/cssgrids-min.css&#x27;
                }
            };
            if (!this._meta) {
                try {
                    var meta,
                        theme = path.join(themeDir, &#x27;theme.json&#x27;);
                    if (Y.Files.exists(theme)) {
                        Y.log(&#x27;Loading theme from &#x27; + theme, &#x27;info&#x27;, &#x27;builder&#x27;);
                        meta = Y.Files.getJSON(theme);
                    } else if (DEFAULT_THEME !== themeDir) {
                        theme = path.join(DEFAULT_THEME, &#x27;theme.json&#x27;);
                        if (Y.Files.exists(theme)) {
                            Y.log(&#x27;Loading theme from &#x27; + theme, &#x27;info&#x27;, &#x27;builder&#x27;);
                            meta = Y.Files.getJSON(theme);
                        }
                    }

                    if (meta) {
                        obj.meta = meta;
                        this._meta = meta;
                    }
                } catch (e) {
                    console.error(&#x27;Error&#x27;, e);
                }
            } else {
                obj.meta = this._meta;
            }
            Y.each(this.data.project, function (v, k) {
                var key = k.substring(0, 1).toUpperCase() + k.substring(1, k.length);
                obj.meta[&#x27;project&#x27; + key] = v;
            });
            return obj;
        },
        /**
         * Populate the meta data for classes
         * @method populateClasses
         * @param {Object} opts The original options
         * @return {Object} The modified options
         */
        populateClasses: function (opts) {
            opts.meta.classes = [];
            Y.each(this.data.classes, function (v) {
                if (v.external) {
                    return;
                }
                opts.meta.classes.push({
                    displayName: v.name,
                    name: v.name,
                    namespace: v.namespace,
                    module: v.module,
                    description: v.description,
                    access: v.access || &#x27;public&#x27;
                });
            });
            opts.meta.classes.sort(this.nameSort);
            return opts;
        },
        /**
         * Populate the meta data for elements
         * @method populateElements
         * @param {Object} opts The original options
         * @return {Object} The modified options
         */
        populateElements: function (opts) {
            opts.meta.elements = [];
            Y.each(this.data.elements, function (v) {
                if (v.external) {
                    return;
                }
                opts.meta.elements.push({
                    displayName: &#x27;&lt;&#x27; + v.name + &#x27;&gt;&#x27;,
                    name: v.name,
                    module: v.module,
                    description: v.description
                });
            });
            opts.meta.elements.sort(this.nameSort);
            return opts;
        },
        /**
         * Populate the meta data for modules
         * @method populateModules
         * @param {Object} opts The original options
         * @return {Object} The modified options
         */
        populateModules: function (opts) {
            var self = this;
            opts.meta.modules = [];
            opts.meta.allModules = [];
            Y.each(this.data.modules, function (v) {
                if (v.external) {
                    return;
                }
                opts.meta.allModules.push({
                    displayName: v.displayName || v.name,
                    name: self.filterFileName(v.name),
                    description: v.description
                });
                if (!v.is_submodule) {
                    var o = {
                        displayName: v.displayName || v.name,
                        name: self.filterFileName(v.name)
                    };
                    if (v.submodules) {
                        o.submodules = [];
                        Y.each(v.submodules, function (i, k) {
                            var moddef = self.data.modules[k];
                            if (moddef) {
                                o.submodules.push({
                                    displayName: k,
                                    description: moddef.description
                                });
                                // } else {
                                //     Y.log(&#x27;Submodule data missing: &#x27; + k + &#x27; for &#x27; + v.name, &#x27;warn&#x27;, &#x27;builder&#x27;);
                            }
                        });
                        o.submodules.sort(self.nameSort);
                    }
                    opts.meta.modules.push(o);
                }
            });
            opts.meta.modules.sort(this.nameSort);
            opts.meta.allModules.sort(this.nameSort);
            return opts;
        },
        /**
         * Populate the meta data for files
         * @method populateFiles
         * @param {Object} opts The original options
         * @return {Object} The modified options
         */
        populateFiles: function (opts) {
            var self = this;
            opts.meta.files = [];
            Y.each(this.data.files, function (v) {
                if (v.external) {
                    return;
                }
                opts.meta.files.push({
                    displayName: v.name,
                    name: self.filterFileName(v.name),
                    path: v.path || v.name
                });
            });

            var tree = {};
            var files = [];
            Y.each(this.data.files, function (v) {
                if (v.external) {
                    return;
                }
                files.push(v.name);
            });
            files.sort();
            Y.each(files, function (v) {
                var p = v.split(&#x27;/&#x27;),
                    par;
                p.forEach(function (i, k) {
                    if (!par) {
                        if (!tree[i]) {
                            tree[i] = {};
                        }
                        par = tree[i];
                    } else {
                        if (!par[i]) {
                            par[i] = {};
                        }
                        if (k + 1 === p.length) {
                            par[i] = {
                                path: v,
                                name: self.filterFileName(v)
                            };
                        }
                        par = par[i];
                    }
                });
            });

            opts.meta.fileTree = tree;

            return opts;
        },
        /**
         * Parses file and line number from an item object and build&#x27;s an HREF
         * @method addFoundAt
         * @param {Object} a The item to parse
         * @return {String} The parsed HREF
         */
        addFoundAt: function (a) {
            var self = this;
            if (a.file &amp;&amp; a.line &amp;&amp; !self.options.nocode) {
                a.foundAt = &#x27;../files/&#x27; + self.filterFileName(a.file) + &#x27;.html#l&#x27; + a.line;
                if (a.path) {
                    a.foundAt = a.path + &#x27;#l&#x27; + a.line;
                }
            }
            return a;
        },
        /**
         * Augments the **DocParser** meta data to provide default values for certain keys as well as parses all descriptions
         * with the &#x60;Markdown Parser&#x60;
         * @method augmentData
         * @param {Object} o The object to recurse and augment
         * @return {Object} The augmented object
         */
        augmentData: function (o) {
            var self = this;
            o = self.addFoundAt(o);
            Y.each(o, function (i, k1) {
                if (i &amp;&amp; i.forEach) {
                    Y.each(i, function (a, k) {
                        if (!(a instanceof Object)) {
                            return;
                        }
                        if (!a.type) {
                            a.type = &#x27;Object&#x27;; //Default type is Object
                        }
                        if (a.final === &#x27;&#x27;) {
                            a.final = true;
                        }
                        if (!a.description) {
                            a.description = &#x27; &#x27;;
                        } else if (!o.extended_from) {
                            a.description = self.markdown(a.description);
                        }
                        if (a.example &amp;&amp; !o.extended_from) {
                            a.example = self.markdown(a.example);
                        }
                        a = self.addFoundAt(a);

                        Y.each(a, function (c, d) {
                            if (c.forEach || (c instanceof Object)) {
                                c = self.augmentData(c);
                                a[d] = c;
                            }
                        });

                        o[k1][k] = a;
                    });
                } else if (i instanceof Object) {
                    i = self.addFoundAt(i);
                    Y.each(i, function (v, k) {
                        if (k === &#x27;final&#x27;) {
                            o[k1][k] = true;
                        } else if (k === &#x27;description&#x27; || k === &#x27;example&#x27;) {
                            if (v.forEach || (v instanceof Object)) {
                                o[k1][k] = self.augmentData(v);
                            } else {
                                o[k1][k] = o.extended_from ? v : self.markdown(v);
                            }
                        }
                    });
                } else if (k1 === &#x27;description&#x27; || k1 === &#x27;example&#x27;) {
                    o[k1] = o.extended_from ? i : self.markdown(i);
                }
            });
            return o;
        },
        /**
         * Makes the default directories needed
         * @method makeDirs
         * @param {Callback} cb The callback to execute after it&#x27;s completed
         */
        makeDirs: function (cb) {
            var self = this;
            var dirs = [&#x27;classes&#x27;, &#x27;elements&#x27;, &#x27;modules&#x27;, &#x27;files&#x27;];
            if (self.options.dumpview) {
                dirs.push(&#x27;json&#x27;);
            }
            var writeRedirect = function (dir, file, cbWriteRedirect) {
                Y.Files.exists(file, function (x) {
                    if (x) {
                        var out = path.join(dir, &#x27;index.html&#x27;);
                        fs.createReadStream(file).pipe(fs.createWriteStream(out));
                    }
                    cbWriteRedirect();
                });
            };
            var defaultIndex = path.join(themeDir, &#x27;assets&#x27;, &#x27;index.html&#x27;);
            var stack = new Y.Parallel();
            Y.log(&#x27;Making default directories: &#x27; + dirs.join(&#x27;,&#x27;), &#x27;info&#x27;, &#x27;builder&#x27;);
            dirs.forEach(function (d) {
                var dir = path.join(self.options.outdir, d);
                Y.Files.exists(dir, stack.add(function (x) {
                    if (!x) {
                        fs.mkdir(dir, &#x27;0777&#x27;, stack.add(function () {
                            writeRedirect(dir, defaultIndex, stack.add(noop));
                        }));
                    } else {
                        writeRedirect(dir, defaultIndex, stack.add(noop));
                    }
                }));
            });
            stack.done(function () {
                if (cb) {
                    cb();
                }
            });
        },


        _resolveUrl: function (url, opts) {
            if (!url) {
                return null;
            }
            if (url.indexOf(&#x27;://&#x27;) &gt;= 0) {
                return url;
            }
            return path.join(opts.meta.projectRoot, url);
        },

        /**
         * Parses &#x60;&lt;pre&gt;&lt;code&gt;&#x60; tags and adds the __prettyprint__ &#x60;className&#x60; to them
         * @method _parseCode
         * @private
         * @param {HTML} html The HTML to parse
         * @return {HTML} The parsed HTML
         */
        _parseCode: function (html) {
            html = html || &#x27;&#x27;;
            //html = html.replace(/&lt;pre&gt;&lt;code&gt;/g, &#x27;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;prettyprint&quot;&gt;&#x27;);
            html = html.replace(/&lt;pre&gt;&lt;code/g, &#x27;&lt;pre class=&quot;code prettyprint&quot;&gt;&lt;code&#x27;);
            return html;
        },
        /**
        * Ported from [Selleck](https://github.com/rgrove/selleck), this handles &#x60;&#x60;&#x60;&#x27;s in fields
        that are not parsed by the **Markdown** parser.
        * @method _inlineCode
        * @private
        * @param {HTML} html The HTML to parse
        * @return {HTML} The parsed HTML
        */
        _inlineCode: function (html) {
            html = html.replace(/\\&#x60;/g, &#x27;`&#x27;);

            html = html.replace(/&#x60;(.+?)&#x60;/g, function (match, code) {
                return &#x27;&lt;code&gt;&#x27; + Y.escapeHTML(code) + &#x27;&lt;/code&gt;&#x27;;
            });

            html = html.replace(/__\{\{SELLECK_BACKTICK\}\}__/g, &#x27;&#x60;&#x27;);

            return html;
        },
        /**
        * Ported from [Selleck](https://github.com/rgrove/selleck)
        Renders the handlebars templates with the default View class.
        * @method render
        * @param {HTML} source The default template to parse
        * @param {Class} view The default view handler
        * @param {HTML} [layout=null] The HTML from the layout to use.
        * @param {Object} [partials=object] List of partials to include in this template
        * @param {Callback} callback
        * @param {Error} callback.err
        * @param {HTML} callback.html The assembled template markup
        */
        render: function (source, view, layout, partials, callback) {
            var html = [];

            // function buffer(line) {
            //     html.push(line);
            // }

            // Allow callback as third or fourth param.
            if (typeof partials === &#x27;function&#x27;) {
                callback = partials;
                partials = {};
            } else if (typeof layout === &#x27;function&#x27;) {
                callback = layout;
                layout = null;
            }
            var parts = Y.merge(partials || {}, {
                layout_content: source
            });
            Y.each(parts, function (partialsSource, name) {
                Y.Handlebars.registerPartial(name, partialsSource);
            });

            if (!TEMPLATE || !this.cacheTemplates) {
                TEMPLATE = Y.Handlebars.compile(layout);
            }


            var _v = {};
            for (var k in view) {
                if (Y.Lang.isFunction(view[k])) {
                    _v[k] = view[k]();
                } else {
                    _v[k] = view[k];
                }
            }
            html = TEMPLATE(_v);
            //html = html.replace(/{{&amp;#x2F;/g, &#x27;{{/&#x27;);


            //html = (Y.Handlebars.compile(html))({});

            html = this._inlineCode(html);
            callback(null, html);
        },
        /**
         * Render the index file
         * @method renderIndex
         * @param {Function} cb The callback fired when complete
         * @param {String} cb.html The HTML to render this view
         * @param {Object} cb.view The View Data
         */
        renderIndex: function (cb) {
            var self = this;

            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {
                if (err) {
                    Y.log(err, &#x27;error&#x27;, &#x27;builder&#x27;);
                    cb(err);
                    return;
                }
                opts.meta.title = self.data.project.name;
                opts.meta.projectRoot = &#x27;./&#x27;;
                opts.meta.projectAssets = &#x27;./assets&#x27;;
                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);
                opts = self.populateClasses(opts);
                opts = self.populateElements(opts);
                opts = self.populateModules(opts);

                var view = new Y.DocView(opts.meta);
                self.render(&#x27;{{&gt;index}}&#x27;, view, opts.layouts.main, opts.partials, function (renderErr, html) {
                    if (renderErr) {
                        Y.log(renderErr, &#x27;error&#x27;, &#x27;builder&#x27;);
                        cb(renderErr);
                        return;
                    }
                    self.files++;
                    cb(html, view);
                });
            });
        },
        /**
         * Generates the index.html file
         * @method writeIndex
         * @param {Callback} cb The callback to execute after it&#x27;s completed
         * @param {String} cb.html The HTML to write index view
         * @param {Object} cb.view The View Data
         */
        writeIndex: function (cb) {
            var self = this,
                stack = new Y.Parallel();

            Y.log(&#x27;Preparing index.html&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
            self.renderIndex(stack.add(function (html, view) {
                stack.html = html;
                stack.view = view;
                if (self.options.dumpview) {
                    Y.Files.writeFile(path.join(self.options.outdir, &#x27;json&#x27;, &#x27;index.json&#x27;), JSON.stringify(view), stack.add(noop));
                }
                Y.Files.writeFile(path.join(self.options.outdir, &#x27;index.html&#x27;), html, stack.add(noop));
            }));

            stack.done(function ( /* html, view */ ) {
                Y.log(&#x27;Writing index.html&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
                cb(stack.html, stack.view);
            });
        },
        /**
         * Render a module
         * @method renderModule
         * @param {Function} cb The callback fired when complete
         * @param {String} cb.html The HTML to render this view
         * @param {Object} cb.view The View Data
         */
        renderModule: function (cb, data, layout) {
            var self = this;
            var stack = new Y.Parallel();

            data.displayName = data.name;
            data.name = self.filterFileName(data.name);
            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {
                if (err) {
                    Y.log(err, &#x27;error&#x27;, &#x27;builder&#x27;);
                    cb(err);
                    return;
                }
                opts.meta = Y.merge(opts.meta, data);

                //opts.meta.htmlTitle = v.name + &#x27;: &#x27; + self.data.project.name;
                opts.meta.title = self.data.project.name;

                opts.meta.moduleName = data.displayName || data.name;
                opts.meta.moduleDescription = self._parseCode(self.markdown(data.description || &#x27; &#x27;));
                opts.meta.file = data.file;
                opts.meta.line = data.line;
                opts.meta = self.addFoundAt(opts.meta);
                opts.meta.projectRoot = &#x27;../&#x27;;
                opts.meta.projectAssets = &#x27;../assets&#x27;;
                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);
                opts = self.populateClasses(opts);
                opts = self.populateElements(opts);
                opts = self.populateModules(opts);
                opts = self.populateFiles(opts);

                if (data.classes &amp;&amp; Object.keys(data.classes).length) {
                    opts.meta.moduleClasses = [];
                    Y.each(Object.keys(data.classes), function (name) {
                        var i = self.data.classes[name];
                        if (i) {
                            opts.meta.moduleClasses.push({
                                name: i.name,
                                displayName: i.name
                            });
                        }
                    });
                    opts.meta.moduleClasses.sort(self.nameSort);
                }
                if (data.elements &amp;&amp; Object.keys(data.elements).length) {
                    opts.meta.moduleElements = [];
                    Y.each(Object.keys(data.elements), function (name) {
                        var i = self.data.elements[name];
                        if (i) {
                            opts.meta.moduleElements.push({
                                name: i.name,
                                displayName: i.name
                            });
                        }
                    });
                    opts.meta.moduleElements.sort(self.nameSort);
                }
                if (data.example &amp;&amp; data.example.length) {
                    if (data.example.forEach) {
                        var e = &#x27;&#x27;;
                        data.example.forEach(function (v) {
                            e += self._parseCode(self.markdown(v));
                        });
                        data.example = e;
                    } else {
                        data.example = self._parseCode(self.markdown(data.example));
                    }
                    opts.meta.example = data.example;
                }
                if (data.submodules &amp;&amp; Object.keys(data.submodules).length) {
                    opts.meta.subModules = [];
                    Y.each(Object.keys(data.submodules), function (name) {
                        var i = self.data.modules[name];
                        if (i) {
                            opts.meta.subModules.push({
                                name: i.name,
                                displayName: i.name,
                                description: i.description
                            });
                        }
                    });
                    opts.meta.subModules.sort(self.nameSort);
                }

                var view = new Y.DocView(opts.meta);
                var mainLayout = opts.layouts[layout];
                self.render(&#x27;{{&gt;module}}&#x27;, view, mainLayout, opts.partials, stack.add(function (renderErr, html) {
                    if (renderErr) {
                        Y.log(renderErr, &#x27;error&#x27;, &#x27;builder&#x27;);
                        cb(renderErr);
                        return;
                    }
                    self.files++;
                    stack.html = html;
                    stack.view = view;
                }));
            });

            stack.done(function () {
                cb(stack.html, stack.view);
            });
        },
        /**
         * Generates the module files under &quot;out&quot;/modules/
         * @method writeModules
         * @param {Callback} cb The callback to execute after it&#x27;s completed
         * @param {String} cb.html The HTML to write module view
         * @param {Object} cb.view The View Data
         */
        writeModules: function (cb, layout) {
            layout = layout || &#x27;main&#x27;;
            var self = this,
                stack = new Y.Parallel();
            stack.html = [];
            stack.view = [];

            var counter = 0;
            Object.keys(self.data.modules).forEach(function (k) {
                if (!self.data.modules[k].external) {
                    counter++;
                }
            });
            Y.log(&#x27;Rendering and writing &#x27; + counter + &#x27; modules pages.&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
            Y.each(self.data.modules, function (v) {
                if (v.external) {
                    return;
                }
                self.renderModule(function (html, view) {
                    stack.html.push(html);
                    stack.view.push(view);
                    if (self.options.dumpview) {
                        Y.Files.writeFile(
                            path.join(self.options.outdir, &#x27;json&#x27;, &#x27;module_&#x27; + v.name + &#x27;.json&#x27;),
                            JSON.stringify(view),
                            stack.add(noop)
                        );
                    }
                    Y.Files.writeFile(path.join(self.options.outdir, &#x27;modules&#x27;, v.name + &#x27;.html&#x27;), html, stack.add(noop));
                }, v, layout);
            });
            stack.done(function () {
                Y.log(&#x27;Finished writing module files&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
                cb(stack.html, stack.view);
            });
        },
        /**
         * Checks an array of items (class items) to see if an item is in that list
         * @method hasProperty
         * @param {Array} a The Array of items to check
         * @param {Object} b The object to find
         * @return Boolean
         */
        hasProperty: function (a, b) {
            var other = false;
            Y.some(a, function (i, k) {
                if ((i.itemtype === b.itemtype) &amp;&amp; (i.name === b.name)) {
                    other = k;
                    return true;
                }
            });
            return other;
        },
        /**
         * Counter for stepping into merges
         * @private
         * @property _mergeCounter
         * @type Number
         */
        _mergeCounter: null,
        /**
         * Merge superclass data into a child class
         * @method mergeExtends
         * @param {Object} info The item to extend
         * @param {Array} classItems The list of items to merge in
         * @param {Boolean} first Set for the first call
         */
        mergeExtends: function (info, classItems, first) {
            var self = this;
            self._mergeCounter = (first) ? 0 : (self._mergeCounter + 1);

            if (self._mergeCounter === 100) {
                throw (&#x27;YUIDoc detected a loop extending class &#x27; + info.name);
            }
            if (info.extends || info.uses) {
                var hasItems = {};
                hasItems[info.extends] = 1;
                if (info.uses) {
                    info.uses.forEach(function (v) {
                        hasItems[v] = 1;
                    });
                }
                self.data.classitems.forEach(function (v) {
                    //console.error(v.class, &#x27;==&#x27;, info.extends);
                    if (hasItems[v.class]) {
                        if (!v.static) {
                            var q,
                                override = self.hasProperty(classItems, v);
                            if (override === false) {
                                //This method was extended from the parent class but not over written
                                //console.error(&#x27;Merging extends from&#x27;, v.class, &#x27;onto&#x27;, info.name);
                                q = Y.merge({}, v);
                                q.extended_from = v.class;
                                classItems.push(q);
                            } else {
                                //This method was extended from the parent and overwritten in this class
                                q = Y.merge({}, v);
                                q = self.augmentData(q);
                                classItems[override].overwritten_from = q;
                            }
                        }
                    }
                });
                if (self.data.classes[info.extends]) {
                    if (self.data.classes[info.extends].extends || self.data.classes[info.extends].uses) {
                        //console.error(&#x27;Stepping down to:&#x27;, self.data.classes[info.extends]);
                        classItems = self.mergeExtends(self.data.classes[info.extends], classItems);
                    }
                }
            }
            return classItems;
        },
        /**
         * Render the class file
         * @method renderClass
         * @param {Function} cb The callback fired when complete
         * @param {String} cb.html The HTML to render this view
         * @param {Object} cb.view The View Data
         */
        renderClass: function (cb, data, layout) {
            var self = this;
            var stack = new Y.Parallel();

            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {
                //console.log(opts);
                if (err) {
                    console.log(err);
                }
                opts.meta = Y.merge(opts.meta, data);

                opts.meta.title = self.data.project.name;
                opts.meta.moduleName = data.name;
                opts.meta.file = data.file;
                opts.meta.line = data.line;
                opts.meta = self.addFoundAt(opts.meta);
                opts.meta.projectRoot = &#x27;../&#x27;;
                opts.meta.projectAssets = &#x27;../assets&#x27;;
                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);

                opts = self.populateClasses(opts);
                opts = self.populateElements(opts);
                opts = self.populateModules(opts);
                opts = self.populateFiles(opts);

                opts.meta.classDescription = self._parseCode(self.markdown(data.description || &#x27; &#x27;));

                opts.meta.methods = [];
                opts.meta.properties = [];
                opts.meta.attrs = [];
                opts.meta.events = [];
                opts.meta.extension_for = null;
                if (data.uses) {
                    opts.meta.uses = data.uses;
                }
                if (data.entension_for &amp;&amp; data.extension_for.length) {
                    opts.meta.extension_for = data.extension_for;
                }

                if (data.extends) {
                    opts.meta.extends = data.extends;
                }

                var classItems = [];
                self.data.classitems.forEach(function (classItem) {
                    if (classItem.class === data.name) {
                        classItems.push(classItem);
                    }
                });

                classItems = self.mergeExtends(data, classItems, true);

                if (data.is_constructor) {
                    var constructor = Y.mix({}, data);
                    constructor = self.augmentData(constructor);
                    constructor.paramsList = [];
                    if (constructor.params) {
                        constructor.params.forEach(function (p) {
                            var name = p.name;
                            if (p.optional) {
                                name = &#x27;[&#x27; + name + ((p.optdefault) ? &#x27;=&#x27; + p.optdefault : &#x27;&#x27;) + &#x27;]&#x27;;
                            }
                            constructor.paramsList.push(name);
                        });
                    }
                    //i.methodDescription = self._parseCode(markdown(i.description));
                    constructor.hasAccessType = constructor.access;
                    constructor.hasParams = constructor.paramsList.length;
                    if (constructor.paramsList.length) {
                        constructor.paramsList = constructor.paramsList.join(&#x27;, &#x27;);
                    } else {
                        constructor.paramsList = &#x27; &#x27;;
                    }
                    constructor.returnType = &#x27; &#x27;;
                    if (constructor.return) {
                        constructor.hasReturn = true;
                        constructor.returnType = constructor.return.type;
                    }
                    //console.error(i);
                    opts.meta.is_constructor = [constructor];
                    if (constructor.example &amp;&amp; constructor.example.length) {
                        if (constructor.example.forEach) {
                            var example = &#x27;&#x27;;
                            constructor.example.forEach(function (v) {
                                example += self._parseCode(self.markdown(v));
                            });
                            constructor.example = example;
                        } else {
                            constructor.example = self._parseCode(self.markdown(constructor.example));
                        }
                    }
                }

                classItems.forEach(function (i) {
                    var e;
                    switch (i.itemtype) {
                    case &#x27;method&#x27;:
                        i = self.augmentData(i);
                        i.paramsList = [];
                        if (i.params &amp;&amp; i.params.forEach) {
                            i.params.forEach(function (p) {
                                var name = p.name;
                                if (p.optional) {
                                    name = &#x27;[&#x27; + name + ((p.optdefault) ? &#x27;=&#x27; + p.optdefault : &#x27;&#x27;) + &#x27;]&#x27;;
                                }
                                i.paramsList.push(name);
                            });
                        }
                        i.methodDescription = self._parseCode(i.description);
                        if (i.example &amp;&amp; i.example.length) {
                            if (i.example.forEach) {
                                e = &#x27;&#x27;;
                                i.example.forEach(function (v) {
                                    e += self._parseCode(self.markdown(v));
                                });
                                i.example = e;
                            } else if (!i.extended_from) {
                                i.example = self._parseCode(self.markdown(i.example));
                            }
                        }
                        i.hasAccessType = i.access;
                        i.hasParams = i.paramsList.length;
                        if (i.paramsList.length) {
                            i.paramsList = i.paramsList.join(&#x27;, &#x27;);
                        } else {
                            i.paramsList = &#x27; &#x27;;
                        }
                        i.returnType = &#x27; &#x27;;
                        if (i.return) {
                            i.hasReturn = true;
                            i.returnType = i.return.type;
                        }

                        // If this item is provided by a module other
                        // than the module that provided the original
                        // class, add the original module name to the
                        // item&#x27;s &#x60;providedBy&#x60; property so we can
                        // indicate the relationship.
                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {
                            i.providedBy = (i.submodule || i.module);
                        }

                        opts.meta.methods.push(i);
                        break;
                    case &#x27;property&#x27;:
                        i = self.augmentData(i);
                        //i.propertyDescription = self._parseCode(markdown(i.description || &#x27;&#x27;));
                        i.propertyDescription = self._parseCode(i.description);
                        if (!i.type) {
                            i.type = &#x27;unknown&#x27;;
                        }
                        if (i.final === &#x27;&#x27;) {
                            i.final = true;
                        }
                        if (i.example &amp;&amp; i.example.length) {
                            if (i.example.forEach) {
                                e = &#x27;&#x27;;
                                i.example.forEach(function (v) {
                                    e += self._parseCode(self.markdown(v));
                                });
                                i.example = e;
                            } else {
                                i.example = self._parseCode(self.markdown(i.example));
                            }
                        }

                        // If this item is provided by a module other
                        // than the module that provided the original
                        // class, add the original module name to the
                        // item&#x27;s &#x60;providedBy&#x60; property so we can
                        // indicate the relationship.
                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {
                            i.providedBy = (i.submodule || i.module);
                        }

                        opts.meta.properties.push(i);
                        break;

                    case &#x27;attribute&#x27;: // fallthru
                    case &#x27;config&#x27;:
                        i = self.augmentData(i);
                        //i.attrDescription = self._parseCode(markdown(i.description || &#x27;&#x27;));
                        i.attrDescription = self._parseCode(i.description);

                        if (i.itemtype === &#x27;config&#x27;) {
                            i.config = true;
                        } else {
                            i.emit = self.options.attributesEmit;
                        }
                        if (i.readonly === &#x27;&#x27;) {
                            i.readonly = true;
                        }

                        if (i.example &amp;&amp; i.example.length) {
                            if (i.example.forEach) {
                                e = &#x27;&#x27;;
                                i.example.forEach(function (v) {
                                    e += self._parseCode(self.markdown(v));
                                });
                                i.example = e;
                            } else {
                                i.example = self._parseCode(self.markdown(i.example));
                            }
                        }

                        // If this item is provided by a module other
                        // than the module that provided the original
                        // class, add the original module name to the
                        // item&#x27;s &#x60;providedBy&#x60; property so we can
                        // indicate the relationship.
                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {
                            i.providedBy = (i.submodule || i.module);
                        }

                        opts.meta.attrs.push(i);
                        break;
                    case &#x27;event&#x27;:
                        i = self.augmentData(i);
                        //i.eventDescription = self._parseCode(markdown(i.description || &#x27;&#x27;));
                        i.eventDescription = self._parseCode(i.description);

                        if (i.example &amp;&amp; i.example.length) {
                            if (i.example.forEach) {
                                e = &#x27;&#x27;;
                                i.example.forEach(function (v) {
                                    e += self._parseCode(self.markdown(v));
                                });
                                i.example = e;
                            } else {
                                i.example = self._parseCode(self.markdown(i.example));
                            }
                        }

                        // If this item is provided by a module other
                        // than the module that provided the original
                        // class, add the original module name to the
                        // item&#x27;s &#x60;providedBy&#x60; property so we can
                        // indicate the relationship.
                        if ((i.submodule || i.module) !== (data.submodule || data.module)) {
                            i.providedBy = (i.submodule || i.module);
                        }

                        opts.meta.events.push(i);
                        break;
                    }
                });

                if (!self.options.dontsortfields) {
                    opts.meta.attrs.sort(self.nameSort);
                    opts.meta.events.sort(self.nameSort);
                    opts.meta.methods.sort(self.nameSort);
                    opts.meta.properties.sort(self.nameSort);
                }

                if (!opts.meta.methods.length) {
                    delete opts.meta.methods;
                }
                if (!opts.meta.properties.length) {
                    delete opts.meta.properties;
                }
                if (!opts.meta.attrs.length) {
                    delete opts.meta.attrs;
                }
                if (!opts.meta.events.length) {
                    delete opts.meta.events;
                }

                var view = new Y.DocView(opts.meta);
                var mainLayout = opts.layouts[layout];
                self.render(&#x27;{{&gt;classes}}&#x27;, view, mainLayout, opts.partials, stack.add(function (renderErr, html) {
                    if (renderErr) {
                        Y.log(renderErr, &#x27;error&#x27;, &#x27;builder&#x27;);
                        cb(renderErr);
                        return;
                    }
                    self.files++;
                    stack.html = html;
                    stack.view = view;
                    stack.opts = opts;
                }));
            });

            stack.done(function () {
                cb(stack.html, stack.view, stack.opts);
            });
        },
        /**
         * Render the element file
         * @method renderElement
         * @param {Function} cb The callback fired when complete
         * @param {String} cb.html The HTML to render this view
         * @param {Object} cb.view The View Data
         */
        renderElement: function (cb, data, layout) {
            var self = this;
            var stack = new Y.Parallel();

            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {
                if (err) {
                    console.log(err);
                }
                opts.meta = Y.merge(opts.meta, data);

                opts.meta.title = self.data.project.name;
                opts.meta.moduleName = data.name;
                opts.meta.file = data.file;
                opts.meta.line = data.line;
                opts.meta = self.addFoundAt(opts.meta);
                opts.meta.projectRoot = &#x27;../&#x27;;
                opts.meta.projectAssets = &#x27;../assets&#x27;;
                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);

                opts = self.populateClasses(opts);
                opts = self.populateElements(opts);
                opts = self.populateModules(opts);
                opts = self.populateFiles(opts);

                opts.meta.elementDescription = self._parseCode(self.markdown(data.description || &#x27; &#x27;));

                if (data.example &amp;&amp; data.example.length) {
                    if (data.example.forEach) {
                        var e = &#x27;&#x27;;
                        data.example.forEach(function (v) {
                            e += self._parseCode(self.markdown(v));
                        });
                        data.example = e;
                    } else {
                        data.example = self._parseCode(self.markdown(data.example));
                    }
                    opts.meta.example = data.example;
                }

                if (!self.options.dontsortfields) {
                    opts.meta.attributes.sort(self.nameSort);
                }

                opts.meta.attributes.forEach(function (a) {
                    a.description = self._parseCode(a.description);
                });

                if (!opts.meta.attributes.length) {
                    delete opts.meta.attributes;
                }

                var view = new Y.DocView(opts.meta);
                var mainLayout = opts.layouts[layout];
                self.render(&#x27;{{&gt;elements}}&#x27;, view, mainLayout, opts.partials, stack.add(function (renderErr, html) {
                    if (renderErr) {
                        Y.log(renderErr, &#x27;error&#x27;, &#x27;builder&#x27;);
                        cb(renderErr);
                        return;
                    }
                    self.files++;
                    stack.html = html;
                    stack.view = view;
                    stack.opts = opts;
                }));
            });

            stack.done(function () {
                cb(stack.html, stack.view, stack.opts);
            });
        },
        /**
         * Generates the class or element files under &quot;out&quot;/classes/ or &quot;out&quot;/elements/
         * @method writeComponents
         * @param {String} type The component type, &quot;classes&quot; or &quot;elements&quot;
         * @param {Callback} cb The callback to execute after it&#x27;s completed
         * @param {String} cb.html The HTML to write class view
         * @param {Object} cb.view The View Data
         */
        writeComponents: function (type, cb, layout) {
            layout = layout || &#x27;main&#x27;;
            var self = this,
                stack = new Y.Parallel();
            stack.html = [];
            stack.view = [];

            var counter = 0;
            Object.keys(self.data[type]).forEach(function (k) {
                if (!self.data[type][k].external) {
                    counter++;
                }
            });
            Y.log(&#x27;Rendering and writing &#x27; + counter + &#x27; class pages.&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
            Y.each(self.data[type], function (v) {
                if (v.external) {
                    return;
                }
                self[type === &#x27;classes&#x27; ? &#x27;renderClass&#x27; : &#x27;renderElement&#x27;](stack.add(function (html, view) {
                    stack.html.push(html);
                    stack.view.push(view);
                    if (self.options.dumpview) {
                        Y.Files.writeFile(
                            path.join(self.options.outdir, &#x27;json&#x27;, type + &#x27;_&#x27; + v.name + &#x27;.json&#x27;),
                            JSON.stringify(view),
                            stack.add(noop)
                        );
                    }
                    Y.Files.writeFile(path.join(self.options.outdir, type, v.name + &#x27;.html&#x27;), html, stack.add(noop));
                }), v, layout);
            });
            stack.done(function () {
                Y.log(&#x27;Finished writing &#x27; + type.replace(/e?s$/, &#x27;&#x27;) + &#x27; files&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
                cb(stack.html, stack.view);
            });
        },
        /**
         * Sort method of array of objects with a property called __name__
         * @method nameSort
         * @param {Object} a First object to compare
         * @param {Object} b Second object to compare
         * @return {Number} 1, -1 or 0 for sorting.
         */
        nameSort: function (a, b) {
            if (!a.name || !b.name) {
                return 0;
            }
            var an = a.name.toLowerCase(),
                bn = b.name.toLowerCase(),
                ret = 0;

            if (an &lt; bn) {
                ret = -1;
            }
            if (an &gt; bn) {
                ret = 1;
            }
            return ret;
        },
        /**
         * Generates the syntax files under &#x60;&quot;out&quot;/files/&#x60;
         * @method writeFiles
         * @param {Callback} cb The callback to execute after it&#x27;s completed
         * @param {String} cb.html The HTML to write file view
         * @param {Object} cb.view The View Data
         */
        writeFiles: function (cb, layout) {
            layout = layout || &#x27;main&#x27;;
            var self = this,
                stack = new Y.Parallel();
            stack.html = [];
            stack.view = [];

            var counter = 0;
            Object.keys(self.data.files).forEach(function (k) {
                if (!self.data.files[k].external) {
                    counter++;
                }
            });
            Y.log(&#x27;Rendering and writing &#x27; + counter + &#x27; source files.&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
            Y.each(self.data.files, function (v) {
                if (v.external) {
                    return;
                }
                self.renderFile(stack.add(function (html, view, data) {
                    if (!view || !data) {
                        return;
                    }
                    stack.html.push(html);
                    stack.view.push(view);
                    if (self.options.dumpview) {
                        Y.Files.writeFile(
                            path.join(self.options.outdir, &#x27;json&#x27;, &#x27;files_&#x27; + self.filterFileName(data.name) + &#x27;.json&#x27;),
                            JSON.stringify(view),
                            stack.add(noop)
                        );
                    }
                    Y.Files.writeFile(
                        path.join(self.options.outdir, &#x27;files&#x27;, self.filterFileName(data.name) + &#x27;.html&#x27;),
                        html,
                        stack.add(noop)
                    );
                }), v, layout);
            });
            stack.done(function () {
                Y.log(&#x27;Finished writing source files&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
                cb(stack.html, stack.view);
            });
        },
        /**
         * Render the source file
         * @method renderFile
         * @param {Function} cb The callback fired when complete
         * @param {String} cb.html The HTML to render this view
         * @param {Object} cb.view The View Data
         */
        renderFile: function (cb, data, layout) {
            var self = this;

            Y.prepare([DEFAULT_THEME, themeDir], self.getProjectMeta(), function (err, opts) {
                if (err) {
                    console.log(err);
                }
                if (!data.name) {
                    return;
                }

                opts.meta = Y.merge(opts.meta, data);

                opts.meta.title = self.data.project.name;
                opts.meta.moduleName = data.name;
                opts.meta.projectRoot = &#x27;../&#x27;;
                opts.meta.projectAssets = &#x27;../assets&#x27;;
                opts.meta.projectLogo = self._resolveUrl(self.data.project.logo, opts);

                opts = self.populateClasses(opts);
                opts = self.populateModules(opts);
                opts = self.populateFiles(opts);

                opts.meta.fileName = data.name;
                fs.readFile(opts.meta.fileName, Y.charset, Y.rbind(function (readErr, str, readOpts, readData) {
                    if (readErr) {
                        Y.log(readErr, &#x27;error&#x27;, &#x27;builder&#x27;);
                        cb(readErr);
                        return;
                    }

                    if (typeof self.options.tabspace === &#x27;string&#x27;) {
                        str = str.replace(/\t/g, self.options.tabspace);
                    }

                    readOpts.meta.fileData = str;
                    var view = new Y.DocView(readOpts.meta, &#x27;index&#x27;);
                    var mainLayout = readOpts.layouts[layout];
                    self.render(&#x27;{{&gt;files}}&#x27;, view, mainLayout, readOpts.partials, function (renderErr, html) {
                        if (renderErr) {
                            Y.log(renderErr, &#x27;error&#x27;, &#x27;builder&#x27;);
                            cb(renderErr);
                            return;
                        }
                        self.files++;
                        cb(html, view, readData);
                    });

                }, this, opts, data));
            });

        },
        /**
         * Write the API meta data used for the AutoComplete widget
         * @method writeAPIMeta
         * @param {Callback} cb The callback to execute when complete
         * @async
         */
        writeAPIMeta: function (cb) {
            Y.log(&#x27;Writing API Meta Data&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
            var self = this;
            this.renderAPIMeta(function (js) {
                fs.writeFile(path.join(self.options.outdir, &#x27;api.js&#x27;), js, Y.charset, cb);
            });
        },
        /**
         * Render the API meta and return the JavaScript
         * @method renderAPIMeta
         * @param {Callback} cb The callback
         * @param {String} cb.apijs The JavaScript code to write API meta data
         * @async
         */
        renderAPIMeta: function (cb) {

            var opts = {
                meta: {}
            };
            opts = this.populateClasses(opts);
            opts = this.populateModules(opts);
            opts = this.populateElements(opts);

            [&#x27;classes&#x27;, &#x27;modules&#x27;, &#x27;elements&#x27;].forEach(function (id) {
                opts.meta[id].forEach(function (v, k) {
                    opts.meta[id][k] = v.name;
                    if (v.submodules) {
                        v.submodules.forEach(function (s) {
                            opts.meta[id].push(s.displayName);
                        });
                    }
                });
                opts.meta[id].sort();
            });

            var apijs = &#x27;YUI.add(&quot;yuidoc-meta&quot;, function(Y) {\n&#x27; +
                &#x27;   Y.YUIDoc = { meta: &#x27; + JSON.stringify(opts.meta, null, 4) + &#x27; };\n&#x27; +
                &#x27;});&#x27;;

            cb(apijs);
        },
        /**
         * Normalizes a file path to a writable filename:
         *
         *    var path = &#x27;lib/file.js&#x27;;
         *    returns &#x27;lib_file.js&#x27;;
         *
         * @method filterFileName
         * @param {String} f The filename to normalize
         * @return {String} The filtered file path
         */
        filterFileName: function (f) {
            return f.replace(/[\/\\]/g, &#x27;_&#x27;);
        },
        /**
         * Compiles the templates from the meta-data provided by DocParser
         * @method compile
         * @param {Callback} cb The callback to execute after it&#x27;s completed
         */
        compile: function (cb) {
            var self = this;
            var starttime = (new Date()).getTime();
            Y.log(&#x27;Compiling Templates&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);

            this.mixExternal(function () {
                self.makeDirs(function () {
                    Y.log(&#x27;Copying Assets&#x27;, &#x27;info&#x27;, &#x27;builder&#x27;);
                    if (!Y.Files.isDirectory(path.join(self.options.outdir, &#x27;assets&#x27;))) {
                        fs.mkdirSync(path.join(self.options.outdir, &#x27;assets&#x27;), &#x27;0777&#x27;);
                    }
                    Y.Files.copyAssets([
                            path.join(DEFAULT_THEME, &#x27;assets&#x27;),
                            path.join(themeDir, &#x27;assets&#x27;)
                        ],
                        path.join(self.options.outdir, &#x27;assets&#x27;),
                        false,
                        function () {
                            var cstack = new Y.Parallel();

                            self.writeModules(cstack.add(function () {
                                self.writeComponents(&#x27;classes&#x27;, cstack.add(function () {
                                    if (!self.options.nocode) {
                                        self.writeFiles(cstack.add(noop));
                                    }
                                }));
                                self.writeComponents(&#x27;elements&#x27;, cstack.add(function () {
                                    if (!self.options.nocode) {
                                        self.writeFiles(cstack.add(noop));
                                    }
                                }));
                            }));
                            /*
                        self.writeModules(cstack.add(noop));
                        self.writeClasses(cstack.add(noop));
                        if (!self.options.nocode) {
                            self.writeFiles(cstack.add(noop));
                        }
                        */
                            self.writeIndex(cstack.add(noop));
                            self.writeAPIMeta(cstack.add(noop));

                            cstack.done(function () {
                                var endtime = (new Date()).getTime();
                                var timer = ((endtime - starttime) / 1000) + &#x27; seconds&#x27;;
                                Y.log(&#x27;Finished writing &#x27; + self.files + &#x27; files in &#x27; + timer, &#x27;info&#x27;, &#x27;builder&#x27;);
                                if (cb) {
                                    cb();
                                }
                            });
                        });
                });
            });
        }
    };
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
